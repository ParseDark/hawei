{"data":{"site":{"siteMetadata":{"title":"大可的技术屋","author":{"name":"Hawei/大可","github":"https://github.com/ParseDark","juejin":"https://juejin.im/user/5a4c68c2f265da43052f036f","twitter":"https://twitter.com/DarkParse","email":"13597213421@163.com"}}},"allMarkdownRemark":{"totalCount":31,"edges":[{"node":{"id":"92e98a29-2bed-5c51-87a9-a43566a6812e","frontmatter":{"title":"11Sweet Pandas Eating Sweets","date":"10 August, 2017","tag":"css","banner":"https://desk-fd.zol-img.com.cn/t_s960x600c5/g2/M00/04/0B/ChMlWl0-oHmIDZvqAAdz3RsOKEYAAMMNwPQhEkAB3P1417.jpg"},"fields":{"slug":"/md/md2/"},"excerpt":"Pandas are really sweet. Here's a video of a panda eating sweets. avatar"}},{"node":{"id":"587116a0-f30f-5264-a245-d39b1a815184","frontmatter":{"title":"Sweet Pandas Eating Sweets","date":"10 August, 2017","tag":"ES5","banner":"https://desk-fd.zol-img.com.cn/t_s960x600c5/g2/M00/04/0B/ChMlWl0-oHmIDZvqAAdz3RsOKEYAAMMNwPQhEkAB3P1417.jpg"},"fields":{"slug":"/md/md2 copy/"},"excerpt":"Pandas are really sweet. Here's a video of a panda eating sweets."}},{"node":{"id":"53b461cf-890c-5496-930d-7a22465b8bd8","frontmatter":{"title":"11. 高级类型之交叉类型、联合类型、类型别名","date":"03 January, 2020","tag":"typescript","banner":"https://desk-fd.zol-img.com.cn/t_s960x600c5/g2/M00/04/0B/ChMlWl0-oHmIDZvqAAdz3RsOKEYAAMMNwPQhEkAB3P1417.jpg"},"fields":{"slug":"/md/typescript/11. 高级类型之交叉类型、联合类型、类型别名/"},"excerpt":"高级类型之交叉类型、联合类型、类型别名 基础组块之上的知识了. 交叉类型 对于交叉类型，把现有的类型进行叠加形成一种新的类型.包含叠加类型的特性. 在js中我们有mixin操作， 就是把两个对象mixin…"}},{"node":{"id":"fbd07cdf-fb1a-506b-9151-2e506ee16c9c","frontmatter":{"title":"1. TS项目配置","date":"03 January, 2020","tag":"typescript","banner":"https://desk-fd.zol-img.com.cn/t_s960x600c5/g2/M00/04/0B/ChMlWl0-oHmIDZvqAAdz3RsOKEYAAMMNwPQhEkAB3P1417.jpg"},"fields":{"slug":"/md/typescript/1. TS项目配置/"},"excerpt":"全局安装ts 初始化ts配置 配置ts文件 npm script command"}},{"node":{"id":"94660469-c949-5d3c-be94-e09a987787f4","frontmatter":{"title":"10.类型兼容","date":"03 January, 2020","tag":"typescript","banner":"https://desk-fd.zol-img.com.cn/t_s960x600c5/g2/M00/04/0B/ChMlWl0-oHmIDZvqAAdz3RsOKEYAAMMNwPQhEkAB3P1417.jpg"},"fields":{"slug":"/md/typescript/10.类型兼容/"},"excerpt":"类型兼容 结构类型 规则： 如果 x 要兼容 y，那么 y 至少具有与 x 相同的属性。 最小化原则吧， 东西少的兼容东西多的，东西多的不能兼容东西少的.最小化原则. 我们做一个简单的实验，我们构建一个类 Person,然后声明一个接口 Dog，Dog 的属性 Person…"}},{"node":{"id":"d1db23c8-7f0e-5a32-9548-741c3a446182","frontmatter":{"title":"13.装饰器","date":"03 January, 2020","tag":"typescript","banner":"https://desk-fd.zol-img.com.cn/t_s960x600c5/g2/M00/04/0B/ChMlWl0-oHmIDZvqAAdz3RsOKEYAAMMNwPQhEkAB3P1417.jpg"},"fields":{"slug":"/md/typescript/13.装饰器/"},"excerpt":"装饰器 解决了什么问题？ 装饰器(decorator)最早在 Python 中被引入,它的主要作用是给一个已有的方法或类扩展一些新的行为，而不是去直接修改它本身. 两个概念：  目前装饰器本质上是一个函数,@expression 的形式其实是一个语法糖, expression…"}},{"node":{"id":"cedcf967-41bf-51ee-b243-552a63718e7b","frontmatter":{"title":"16.赋值断言、is 关键字、可调用类型注解和类型推导","date":"03 January, 2020","tag":"typescript","banner":"https://desk-fd.zol-img.com.cn/t_s960x600c5/g2/M00/04/0B/ChMlWl0-oHmIDZvqAAdz3RsOKEYAAMMNwPQhEkAB3P1417.jpg"},"fields":{"slug":"/md/typescript/16.赋值断言、is 关键字、可调用类型注解和类型推导/"},"excerpt":"赋值断言、is 关键字、可调用类型注解和类型推导 明确赋值断言 TypeScript 2.7 引入了一个新的控制严格性的标记: --strictPropertyInitialization 它的作用就是保证变量声明和实例属性都会有初始值: 该属性本来就可以是 undefined…"}},{"node":{"id":"ae9a4cc8-eb03-5413-949e-c007664230fb","frontmatter":{"title":"12.可辨识联合类型","date":"03 January, 2020","tag":"typescript","banner":"https://desk-fd.zol-img.com.cn/t_s960x600c5/g2/M00/04/0B/ChMlWl0-oHmIDZvqAAdz3RsOKEYAAMMNwPQhEkAB3P1417.jpg"},"fields":{"slug":"/md/typescript/12.可辨识联合类型/"},"excerpt":"可辨识联合类型 两个关键概念， 字面量类型， 类型字面量. 字面量类型 字面量（Literal Type）主要分为 真值字面量类型（boolean literal types）,数字字面量类型（numeric literal types）,枚举字面量类型（enum literal…"}},{"node":{"id":"0d28d35e-3664-59ee-b191-eab28f090107","frontmatter":{"title":"14.高级装饰器","date":"03 January, 2020","tag":"typescript","banner":"https://desk-fd.zol-img.com.cn/t_s960x600c5/g2/M00/04/0B/ChMlWl0-oHmIDZvqAAdz3RsOKEYAAMMNwPQhEkAB3P1417.jpg"},"fields":{"slug":"/md/typescript/14.高级装饰器/"},"excerpt":"高级装饰器 上一节说的基本的装饰器： : 类装饰器、属性装饰器、方法装饰器、访问符装饰器. 这一节说的是非常用的，但是在基础库里用得很多的高级装饰器. 参数装饰器 参数装饰器，顾名思义是用于修饰参数的装饰器。 参数详解 target…"}},{"node":{"id":"e1e9cb3a-d463-5bae-9ddb-65793b209c21","frontmatter":{"title":"17.TypeScript 与 React 实战","date":"03 January, 2020","tag":"typescript","banner":"https://desk-fd.zol-img.com.cn/t_s960x600c5/g2/M00/04/0B/ChMlWl0-oHmIDZvqAAdz3RsOKEYAAMMNwPQhEkAB3P1417.jpg"},"fields":{"slug":"/md/typescript/17.TypeScript 与 React 实战/"},"excerpt":""}},{"node":{"id":"5236570b-c747-5ad9-adc2-9dd2d4992a13","frontmatter":{"title":"2. TS原始类型","date":"03 January, 2020","tag":"typescript","banner":"https://desk-fd.zol-img.com.cn/t_s960x600c5/g2/M00/04/0B/ChMlWl0-oHmIDZvqAAdz3RsOKEYAAMMNwPQhEkAB3P1417.jpg"},"fields":{"slug":"/md/typescript/2. TS原始类型/"},"excerpt":"基本类型 Number String Null Symbol BigInt Number 包括二进制/十进制/十六进制 String 就字符串类型 Null 只有两个Null 和 undefined Symbol Symbol 的值是唯一不变的 BigInt"}},{"node":{"id":"9ea13c7a-61a2-575f-8ca6-6b420d016b6b","frontmatter":{"title":"3. TS复杂类型","date":"03 January, 2020","tag":"typescript","banner":"https://desk-fd.zol-img.com.cn/t_s960x600c5/g2/M00/04/0B/ChMlWl0-oHmIDZvqAAdz3RsOKEYAAMMNwPQhEkAB3P1417.jpg"},"fields":{"slug":"/md/typescript/3. TS复杂类型/"},"excerpt":"比较复杂的类型 any unknown never object 数组/元祖 any anyScript unknown 和any很像，与 any 的不同之处,虽然它们都可以是任何类型,但是当 unknown 类型被确定是某个类型之前,它不能被进行任何操作比如实例化、getter…"}},{"node":{"id":"7cf9e18a-b0c6-5857-90c0-d274e11b1931","frontmatter":{"title":"6. class","date":"03 January, 2020","tag":"typescript","banner":"https://desk-fd.zol-img.com.cn/t_s960x600c5/g2/M00/04/0B/ChMlWl0-oHmIDZvqAAdz3RsOKEYAAMMNwPQhEkAB3P1417.jpg"},"fields":{"slug":"/md/typescript/6. class/"},"excerpt":"class 抽象类 抽象类做为其它派生类的基类使用,它们一般不会直接被实例化,不同于接口,抽象类可以包含成员的实现细节。 抽象类不可被实例化， 只可以通过继承被实现。 访问限定符 TypeScript 中有三类访问限定符，分别是: public、private、protected…"}},{"node":{"id":"4d9c4b6e-4b49-5d94-953a-20bbe2772fd9","frontmatter":{"title":"基于node-fetch二次封装","date":"10 August, 2017","tag":"ES6","banner":"https://desk-fd.zol-img.com.cn/t_s960x600c5/g2/M00/04/0B/ChMlWl0-oHmIDZvqAAdz3RsOKEYAAMMNwPQhEkAB3P1417.jpg"},"fields":{"slug":"/md/fetch/"},"excerpt":"背景：项目中我们使用 koa2 作为静态资源+转发代理服务器.前端 react. 冲突：后端对于某些业务逻辑执着于状态返回 500/400， 而不是使用统一的错误码， 我们又必须拿到错误信息.\n我们在 koa2 使用的 fetch 库为：request-promise…"}},{"node":{"id":"00bb2695-55cb-5e46-9d14-0e857b4060a0","frontmatter":{"title":"5.接口类型","date":"03 January, 2020","tag":"typescript","banner":"https://desk-fd.zol-img.com.cn/t_s960x600c5/g2/M00/04/0B/ChMlWl0-oHmIDZvqAAdz3RsOKEYAAMMNwPQhEkAB3P1417.jpg"},"fields":{"slug":"/md/typescript/5.接口类型/"},"excerpt":"接口类型 鸭子辨别法， 如果这个物体两只脚， 也会嘎嘎嘎的叫，那么就是鸭子。 而接口正是这种机制。 提供一个命名空间，如果符合我们对其的定义，那么都属于这个接口类型。 使用 一般用于我们函数中，自定义参数.例如： 如果我们基于ts…"}},{"node":{"id":"0f063453-dccf-5819-83de-2ff4430fa0d6","frontmatter":{"title":"8. 泛型","date":"03 January, 2020","tag":"typescript","banner":"https://desk-fd.zol-img.com.cn/t_s960x600c5/g2/M00/04/0B/ChMlWl0-oHmIDZvqAAdz3RsOKEYAAMMNwPQhEkAB3P1417.jpg"},"fields":{"slug":"/md/typescript/8. 泛型/"},"excerpt":"…"}},{"node":{"id":"cba5d7e5-ff23-5ab0-be2d-da6e2d05f20e","frontmatter":{"title":"7. function","date":"03 January, 2020","tag":"typescript","banner":"https://desk-fd.zol-img.com.cn/t_s960x600c5/g2/M00/04/0B/ChMlWl0-oHmIDZvqAAdz3RsOKEYAAMMNwPQhEkAB3P1417.jpg"},"fields":{"slug":"/md/typescript/7. funciton/"},"excerpt":"函数(Function) 定义函数类型 函数的参数详解 可选参数 默认参数 rest 参数 重载（Overload） 这里没看懂。。。。"}},{"node":{"id":"c62be9c7-9db6-5ce5-a6a7-82d8002acee9","frontmatter":{"title":"4. 枚举类型","date":"03 January, 2020","tag":"typescript","banner":"https://desk-fd.zol-img.com.cn/t_s960x600c5/g2/M00/04/0B/ChMlWl0-oHmIDZvqAAdz3RsOKEYAAMMNwPQhEkAB3P1417.jpg"},"fields":{"slug":"/md/typescript/4. 枚举类型/"},"excerpt":"…"}},{"node":{"id":"5aa69f44-9a01-5712-a536-17b28214b67f","frontmatter":{"title":"webWorker 入坑","date":"29 March, 2020","tag":"worker","banner":"https://desk-fd.zol-img.com.cn/t_s960x600c5/g2/M00/04/0B/ChMlWl0-oHmIDZvqAAdz3RsOKEYAAMMNwPQhEkAB3P1417.jpg"},"fields":{"slug":"/md/newBrowserApi/work/"},"excerpt":"webworker 我们知道js是单线程语言,虽然我们有类似于Promise/async/await/generator这样的语法，让我们进行一些异步操作.\n但是，对于一些大计算量的任务，js还无法胜任。\n于是我们有了webworker,webworker…"}},{"node":{"id":"c87c01ad-62b1-5eda-90d3-a6c6e74c849a","frontmatter":{"title":"9.类型断言与类型守卫","date":"03 January, 2020","tag":"typescript","banner":"https://desk-fd.zol-img.com.cn/t_s960x600c5/g2/M00/04/0B/ChMlWl0-oHmIDZvqAAdz3RsOKEYAAMMNwPQhEkAB3P1417.jpg"},"fields":{"slug":"/md/typescript/9.类型断言与类型守卫/"},"excerpt":"类型断言 类型断言解决了什么问题 在js写这代码没问题，但是在ts下，则会报错. 所以我们需要在初始化person的时候，去给person进行断言，告诉ts变量信息. 双重断言 很显然，由于ts的机制，我们不可以把一个string作为person…"}},{"node":{"id":"7ddf716a-f77b-5277-983b-8c7c71b69654","frontmatter":{"title":"hook基础-Portals","date":"03 January, 2020","tag":"react-hook","banner":"https://desk-fd.zol-img.com.cn/t_s960x600c5/g2/M00/04/0B/ChMlWl0-oHmIDZvqAAdz3RsOKEYAAMMNwPQhEkAB3P1417.jpg"},"fields":{"slug":"/md/react/createPortal/"},"excerpt":"Portals 提供渲染与root节点之外的方法. API 用法 最常见的用法是模态框， 全局的loading 一个 portal 的典型用例是当父组件有 overflow: hidden 或 z-index…"}},{"node":{"id":"613a2337-c4c1-5169-85ef-21d0f6734f13","frontmatter":{"title":"关于hook的最佳实践","date":"03 January, 2020","tag":"react-hook","banner":"https://desk-fd.zol-img.com.cn/t_s960x600c5/g2/M00/04/0B/ChMlWl0-oHmIDZvqAAdz3RsOKEYAAMMNwPQhEkAB3P1417.jpg"},"fields":{"slug":"/md/react/100个hook案例/"},"excerpt":"关于hook的最佳实践 使用useState达到forceUpdate Class组件可以通过forceUpdate实例方法来触发强制重新渲染。使用useState也可以模拟相同的效果： 使用react-hook封装localStorage的操作 简而言之， 把store…"}},{"node":{"id":"862b2a1a-127b-5691-9375-0327562d5bc2","frontmatter":{"title":"hook基础-context","date":"03 January, 2020","tag":"react-hook","banner":"https://desk-fd.zol-img.com.cn/t_s960x600c5/g2/M00/04/0B/ChMlWl0-oHmIDZvqAAdz3RsOKEYAAMMNwPQhEkAB3P1417.jpg"},"fields":{"slug":"/md/react/context/"},"excerpt":"context context是针对中小型应用，没有复杂的状态管理的需求， 提供的内置状态管理工具. 官方定义： Context 提供了一个无需为每层组件手动添加 props，就能在组件树间进行数据传递的方法。 如果没有context…"}},{"node":{"id":"693324a3-bad4-580b-af7c-9155ce3ace60","frontmatter":{"title":"15. Reflect Metadata","date":"03 January, 2020","tag":"typescript","banner":"https://desk-fd.zol-img.com.cn/t_s960x600c5/g2/M00/04/0B/ChMlWl0-oHmIDZvqAAdz3RsOKEYAAMMNwPQhEkAB3P1417.jpg"},"fields":{"slug":"/md/typescript/15. Reflect Metadata/"},"excerpt":"Reflect Metadata 概括 之后我们就可以用装饰器来获取、添加元数据了. 结论就是 Relfect Metadata，可以通过装饰器来给类添加一些自定义的信息 然后通过反射将这些信息提取出来 也可以通过反射来添加这些信息 常用api 参数解释 Metadata Key…"}},{"node":{"id":"c56fe4e9-87b1-5504-8bd4-0c0c4c5d236d","frontmatter":{"title":"ES新语法点: entries | Map ","date":"29 March, 2020","tag":"ES6","banner":"https://desk-fd.zol-img.com.cn/t_s960x600c5/g2/M00/04/0B/ChMlWl0-oHmIDZvqAAdz3RsOKEYAAMMNwPQhEkAB3P1417.jpg"},"fields":{"slug":"/md/es6/es6/"},"excerpt":"Object.entries 入参： 对象\n作用： 获取对象的枚举属性， 并且返回一个数组，数组包含一个二元组\n注意： 原型链上的key-value不可枚举 Map Map保存键值对. 语法 特征： 可以使用for..of遍历Map key值不相等 Object和Map…"}},{"node":{"id":"21fcfe19-3a12-521d-baac-047aae943f2e","frontmatter":{"title":"hook基础-useRef/useCallback/useMemo/useReducer","date":"03 January, 2020","tag":"react-hook","banner":"https://desk-fd.zol-img.com.cn/t_s960x600c5/g2/M00/04/0B/ChMlWl0-oHmIDZvqAAdz3RsOKEYAAMMNwPQhEkAB3P1417.jpg"},"fields":{"slug":"/md/react/不常见hook/"},"excerpt":"hook-非常见 useRef 顾名思义，ref获取引用.该hook作用是获取一个可变变量的引用.并且保持它最新的值， 它的结构是：{current: ....}, current…"}},{"node":{"id":"bdc9c04a-527e-55d8-a38f-365b627c5d8a","frontmatter":{"title":"零散记忆点","date":"03 January, 2020","tag":"待分类","banner":"https://desk-fd.zol-img.com.cn/t_s960x600c5/g2/M00/04/0B/ChMlWl0-oHmIDZvqAAdz3RsOKEYAAMMNwPQhEkAB3P1417.jpg"},"fields":{"slug":"/md/react/hook-零散记忆点/"},"excerpt":"基本hook-useState/useEffect/useContext 注意点：\n\t1. useState： 永远返回一个数组，0是数据本身， 1是封装修改数据的方法.\n\t2. useEffect: \n\t\ta. 副作用， 至少执行一次.\n\t\tb. 注意return…"}},{"node":{"id":"6509edb6-fba3-551e-8eb1-72b127498bfe","frontmatter":{"title":"styled-components基础","date":"03 January, 2020","tag":"css-in-js","banner":"https://desk-fd.zol-img.com.cn/t_s960x600c5/g2/M00/04/0B/ChMlWl0-oHmIDZvqAAdz3RsOKEYAAMMNwPQhEkAB3P1417.jpg"},"fields":{"slug":"/md/styled-component/base/"},"excerpt":"styled-components 是什么？  Styled-Components是解决css-in-js较为成熟的npm包. 为什么， 解决了什么问题？  主要解决的问题： css-in-js…"}},{"node":{"id":"6daad2b1-47d8-59b6-b4b4-7006bbc50776","frontmatter":{"title":"基于hook的状态管理tools","date":"03 January, 2020","tag":"state-manage","banner":"https://desk-fd.zol-img.com.cn/t_s960x600c5/g2/M00/04/0B/ChMlWl0-oHmIDZvqAAdz3RsOKEYAAMMNwPQhEkAB3P1417.jpg"},"fields":{"slug":"/md/react/brisk-ui-stateManage/"},"excerpt":"Brisk-ui-stateManage 1. combineReducers---合并reducer 这个是redux中的合并reducer函数.作用是把多个reducer合并成一个.一个application只有一个reducer. 关键点：  检测reducers…"}},{"node":{"id":"41813428-d197-539f-a032-00ef777603a3","frontmatter":{"title":"2019年度总结：下一个阶段","date":"03 January, 2020","tag":"年终总结","banner":"https://desk-fd.zol-img.com.cn/t_s960x600c5/g2/M00/04/0B/ChMlWl0-oHmIDZvqAAdz3RsOKEYAAMMNwPQhEkAB3P1417.jpg"},"fields":{"slug":"/md/2019年终总结/"},"excerpt":"…"}},{"node":{"id":"7b9776c1-a9dc-54ba-ba37-92e319a810c3","frontmatter":{"title":"chapter1: 构造过程抽象","date":"07 April, 2020","tag":"SICS","banner":"https://desk-fd.zol-img.com.cn/t_s960x600c5/g2/M00/04/0B/ChMlWl0-oHmIDZvqAAdz3RsOKEYAAMMNwPQhEkAB3P1417.jpg"},"fields":{"slug":"/md/Structure and Interpretation of Computer Programs/chapter1: 构造过程抽象/"},"excerpt":"程序设计的基本元素 基本表达式： 例如语句定义， 运算符 组合的方法: 函数定义， 分支， 循环语句 抽象的方法： 例如prototype/class/compose…"}}]}}}