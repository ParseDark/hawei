{"componentChunkName":"component---src-templates-blog-post-js","path":"/md/react/brisk-ui-stateManage/","result":{"data":{"markdownRemark":{"html":"<h1>Brisk-ui-stateManage</h1>\n<h3>1. <code>combineReducers</code>---合并reducer</h3>\n<p>这个是redux中的合并reducer函数.作用是把多个reducer合并成一个.一个application只有一个reducer.</p>\n<p>关键点： </p>\n<ol>\n<li>检测reducers类型错误-></li>\n<li>合并reducer-></li>\n<li>\n<p>每个action计算每次最新的state并且返回->Done\n<em>实现</em></p>\n<pre><code class=\"language-js\">reducerMap\nconst combineReducer = (reducerMap) => {\n// reducersMap转换二元组\nconst reducers = Object.entries(reducerMap);\n// 校验reducers合法性： function类型\nreducers.forEach(([name, reducer]) => {\n    if(typeof reducer !== 'function') {\n        throw Error(`reducer ${name} is not a functon.`);\n    }\n})\n// 合并reducers\nreturn (prevCombinedState = {}, action)  => {\n    // 浅拷贝\n    const newCombinedState = {...prevCombinedState};\n    reducers.forEach(([name, reducer]) => {\n        const pervState = prevCombinedState[name];\n        const newState = reducer(pervCombinedState[name], action);\n        if(newState !== prevState) {\n            newCombinedState[name] = newState;\n        }\n    })\n\n    return newCombinedState;\n}\n}\n</code></pre>\n</li>\n</ol>\n<h3>2. <code>StoreProvider</code>---完成store的链接与注入</h3>\n<p>这个是一个封装的Provider的jsx组件， 在里面完成了reducer/store的初始化和链接, 以及children的传递.</p>\n<p>关键点：</p>\n<ol>\n<li>useReducer初始化reduers-></li>\n<li>useStoreMiddleware自定义hook挂载中间件-></li>\n<li>useRef链接初始state->Done</li>\n</ol>\n<p>疑惑点： </p>\n<ul>\n<li>\n<p>useStoreMiddleware在这里做了什么事？</p>\n<pre><code class=\"language-js\">import React, { createContext, useReducer, useRef } from 'react';\nimport PropTypes from 'prop-types';\nimport useStoreMiddleware from './useStoreMiddleware';\n</code></pre>\n</li>\n</ul>\n<p>// 创建一个空的Context对象对。当 React 渲染订阅这 个Context 对象的组件时，它将从组件树中匹配最接近的 Provider 中读取当前的 context 值。\n// 在组件中使用provider注入.相当于容器\n// 使用export暴露出去主要是用于之后使用useContext()\nexport const StoreContext = createContext();</p>\n<p>const StoreProvider = ({\nchildren, reducer, middleware,\n}) => {\n// 从StoreProvide参数中获取reducer并且使用useReducer初始化\nconst [state, dispatch] = useReducer(reducer);\n// 挂载中间件\nconst wrappedDispatcher = useStoreMiddleware([state, dispatch], middleware);\n// 初始化store\nconst store = [state, wrappedDispatcher];\n// 初始化store默认值\nconst storeInitialized = useRef(false);</p>\n<p>  if (storeInitialized.current === false) {\nstoreInitialized.current = true;\nwrappedDispatcher({ type: 'store/initialize' });\n}</p>\n<p>  return (\n&#x3C;StoreContext.Provider value={store}>\n{children}\n&#x3C;/StoreContext.Provider>\n);\n};</p>\n<pre><code>### 3. useStoreMiddleware --- 中间件挂载\n提供了一个useStore自定义hook来完成中间件的挂载。\n\n挂载流程：\n1. 检测中间件list(如果没有中间件，返回对应的dispacth函数)->\n2. 执行中间件->\n3. 执行检查(看是否需要初始化---创建的生命周期)->\n4. 执行依赖挂载(对于state用effect进行监听， 如果产生变化， 则重新执行中间件的计算)->\n5. 返回包裹了中间件改变前需要触发的检查(dispatch前的生命周期)->Done\n\n```js\nimport { useEffect, useRef, useMemo } from 'react';\n\nconst useStoreMiddleware = (store, middlewareSettings) => {\n  const middlewareWaitingForInitialization = useRef(true);\n  const useEffectFirstLoad = useRef(true);\n  const [state, dispatch] = store;\n\n  // 如果没有中间件, 直接返回dispatch函数， 供reducer操作， 完成store的修改\n  if (middlewareSettings === undefined\n    || (Array.isArray(middlewareSettings) &#x26;&#x26; middlewareSettings.length === 0)) {\n    return dispatch;\n  }\n\n  // 如果存在中间件， 那么执行中间件， 并且使用useMemo进行缓存处理\n  // useMemo: \n  // 疑问： 在这里就把它计算出来了吗?\n  // 是的，没错\n  const middlewareList = useMemo(\n    () => (Symbol.iterator in middlewareSettings\n      ? [...middlewareSettings].map(middleware => middleware(store))\n      : [middlewareSettings(store)]),\n    [middlewareSettings],\n  );\n\n  // 如果是首次加载， 并且提供了中间件初始化函数， 那么进行数据的初始化， 并且把标识是否初始化的flag改为false, 类似数据初始化的生命周期\n  if (middlewareWaitingForInitialization.current) {\n    middlewareList.forEach((middleware) => {\n      if (typeof middleware.initialize === 'function') {\n        middleware.initialize(store);\n      }\n    });\n    middlewareWaitingForInitialization.current = false;\n  }\n  // 数据监听， 监听state的变化， 如果发生改变， 并且不是首次执行， 则说明数据发生了改变， 触发中间件中的提交后函数（我觉得类似数据改变时触发的生命周期）\n  useEffect(\n    () => {\n      if (!useEffectFirstLoad.current) {\n        middlewareList.forEach((middleware) => {\n          if (typeof middleware.afterDispatch === 'function') {\n            middleware.afterDispatch(state);\n          }\n        });\n      }\n      useEffectFirstLoad.current = false;\n    },\n    [state],\n  );\n\n  return (action) => {\n    // 那么这个就是reducer触发dispatch，之前的生命周期\n    middlewareList.forEach((middleware) => {\n      if (typeof middleware.beforeDispatch === 'function') {\n        middleware.beforeDispatch(state, action);\n      }\n    });\n    // 通过这种方式， 在dispatch前增加了一个动作， 其实这就是钩子， 在dispatch前增加了一个钩子\n    return dispatch(action);\n  };\n};\n// 那么总结一下： 对于redux的中间件包含： initialize-afterDispatch-beforeDispatch 三个周期(或者说函数)， 需要重点关注\n</code></pre>\n<p>一个常见的中间件</p>\n<pre><code class=\"language-js\">const logger = () => {\n  let trace = {};\n  return ({\n    beforeDispatch: (prevState, action) => {\n      trace = {\n        prevState,\n        action,\n      };\n    },\n    afterDispatch: (nextState) => {\n      trace = {\n        ...trace,\n        nextState,\n      };\n      // eslint-disable-next-line no-console\n      console.table(trace);\n    },\n  });\n};\n\nexport default logger;\n</code></pre>\n<h3>4. <code>useStore</code></h3>\n<p>这个相当于访问总Store的门口，而我们的钥匙就是对应的filed字段.</p>\n<p>疑问：\n入参为store的文件路径？是reduce的name值.</p>\n<p>出参类似useState的出参， 一个二元组， 0为对应的数据本身， 1为修改该数据的方法.</p>\n<p>解析：</p>\n<ol>\n<li>用useContext从StoreContext取出二元组[state, dispatch`]</li>\n<li>根据入参从state取出对应的值subState(并且使用useMemo进行缓存, 保证大store下的性能)</li>\n<li>入参增强了useStore, 可以对数据进行一步处理</li>\n<li>返回subState， 与dispatch的二元组， 符合hook规范</li>\n</ol>\n<pre><code class=\"language-js\">import { useContext, useMemo } from 'react';\nimport { StoreContext } from './StoreProvider';\n\n/**\n * @param {string} [field]\n *   give a field name to get a sub-state\n *\n * @param {function} [selector]\n *   a selector function that'll be memoized,\n *   or a string of state property.\n */\nconst useStore = (...args) => {\n  // 这里会返回一个二元组： 1. state本身 2. 返回修改state的函数， 也就是dispatch\n  const store = useContext(StoreContext);\n\n  const [state, dispatch] = store;\n  // 这相当于从state取东西的时候做一个缓存\n  // 根据入参判断：\n  // 1. 如果第一个参数类型为string, 把它当作state的一个filed\n  //    1. 1如果第二个参数为函数， 那么把它当作一个过滤函数(state) => {return filter(state)}\n  // 2. 如果第1个参数为函数， 那么把它当作一个过滤函数(state) => {return filter(state)}\n  // 3. 如果第一个参函数为空， 报错\n  // 返回值：\n  // 所以这里的返回值是一个二元组：[带缓存的state, dispatch]\n  // 总结\n  // 我的理解啊，在这里dispatch并没做啥改动， 就做了一个传递\n  // 在useStore里，我们主要是对从state中取值进行了一个增强， 基本功能是通过filed取对应的state, \n  // 增强功能是增加了一个数据处理器， 可以先对数据进行粗粒度的处理\n  // 然后再用hook常用的形式返回，便于调用\n  const memoizedSubState = useMemo(() => {\n    let subState = state;\n    const firstParamType = typeof args[0];\n    if (firstParamType === 'string') {\n      // if first param is string, take it as 'field' name\n      const field = args[0];\n      subState = state &#x26;&#x26; state[field];\n\n      // only when first param is string, second param could be a selector function.\n      if (typeof args[1] === 'function') {\n        const selector = args[1];\n        subState = selector(subState);\n      }\n    } else if (firstParamType === 'function') {\n      // if first parameter is a function, take it as the selector.\n      const selector = args[0];\n      subState = selector(state);\n    } else if (firstParamType !== 'undefined') {\n      console.error(`Selector should either be a string or a function but received ${firstParamType}.`);\n    }\n    return subState;\n  }, [state, ...args]);\n\n  return [memoizedSubState, dispatch];\n};\n\nexport default useStore;\n</code></pre>\n<p>至此， 对于brisk-stateManage的源码就算结束了。很精妙和精巧.</p>","frontmatter":{"title":"基于hook的状态管理tools","date":"03 January, 2020","tag":"state-manage","banner":"https://desk-fd.zol-img.com.cn/t_s960x600c5/g2/M00/04/0B/ChMlWl0-oHmIDZvqAAdz3RsOKEYAAMMNwPQhEkAB3P1417.jpg"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/md/react/brisk-ui-stateManage/"}}}