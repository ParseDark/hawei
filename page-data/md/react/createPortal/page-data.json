{"componentChunkName":"component---src-templates-blog-post-js","path":"/md/react/createPortal/","result":{"data":{"markdownRemark":{"html":"<h1>Portals</h1>\n<p>提供渲染与root节点之外的方法.</p>\n<h2>API</h2>\n<pre><code class=\"language-js\">// arg1: 可渲染的React组件\n// arg2: 要渲染的容器\nReactDOM.createPortal(child, container);\n</code></pre>\n<h2>用法</h2>\n<p>最常见的用法是模态框， 全局的loading</p>\n<pre><code class=\"language-js\">// 日常我们使用react的时候， 都是return一个jsx， 供react渲染\nrender() {\n    return (\n        &#x3C;div>\n            {this.props.children} \n        &#x3C;/div>\n    )\n}\n\n// 但有时候， 把我们的组件渲染在父节点之外是有必要的\nrender() {\n    return ReactDOM.createPortal(\n        this.props.children,\n        domNode\n    )\n}\n</code></pre>\n<p>一个 portal 的典型用例是当父组件有 overflow: hidden 或 z-index 样式时，但你需要子组件能够在视觉上“跳出”其容器。例如，对话框、悬浮卡以及提示框：</p>\n<h2>注意：</h2>\n<p>如果使用了事件， 那么在父节点是可以捕获到对应的事件的.</p>","frontmatter":{"title":"hook基础-Portals"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/md/react/createPortal/"}}}