{"componentChunkName":"component---src-templates-blog-post-js","path":"/md/react/不常见hook/","result":{"data":{"markdownRemark":{"html":"<h1>hook-非常见</h1>\n<h2>useRef</h2>\n<p>顾名思义，ref获取引用.该hook作用是获取一个可变变量的引用.并且保持它最新的值， 它的结构是：{current: ....}, current永远都是最新的， 不受闭包的影响。</p>\n<p>一句话， 获取最新的状态改变，但你不希望它改变的时候你收到通知, 并重新渲染.（像effect)</p>\n<p>userRef两个应用</p>\n<ol>\n<li>用于变量： 类似定时器id啊之类的， 需要时刻更新它最新的值.</li>\n<li>\n<p>用于dom元素：获取ref\n<a href=\"https://codesandbox.io/s/github/btholt/react-hooks-examples/tree/master/?module=%2Fsrc%2FRef.js\">ref</a></p>\n<pre><code class=\"language-js\">import React, { useState, useEffect, useRef } from \"react\";\n</code></pre>\n</li>\n</ol>\n<p>const RefComponent = () => {\nconst [stateNumber, setStateNumber] = useState(0);\nconst numRef = useRef(0);</p>\n<p>  function incrementAndDelayLogging() {\nsetStateNumber(stateNumber + 1);\nnumRef.current++;\nsetTimeout(\n// 在alert内 stateNumber受闭包影响\n// numRef总是最新的， 不受闭包影响\n() => alert(<code>state: ${stateNumber} | ref: ${numRef.current}</code>),\n1000\n);\n}</p>\n<p>  return (\n<div>\n<h1>useRef Example</h1>\n<button onClick={incrementAndDelayLogging}>delay logging</button>\n<h4>state: {stateNumber}</h4>\n<h4>ref: {numRef.current}</h4>\n</div>\n);\n};</p>\n<p>export default RefComponent;</p>\n<pre><code>```js\nfunction TextInputWithFocusButton() {\n  const inputEl = useRef(null);// 用useState？当时还未渲染呢， 怎么使用, 用ref存元素算是最常用的方法了\n  const onButtonClick = () => {\n    // `current` 指向已挂载到 DOM 上的文本输入元素\n    inputEl.current.focus();\n  };\n  return (\n    &#x3C;>\n      &#x3C;input ref={inputEl} type=\"text\" />\n      &#x3C;button onClick={onButtonClick}>Focus the input&#x3C;/button>\n    &#x3C;/>\n  );\n}\n</code></pre>\n<h2>useReducer</h2>\n<p>用过redux吗？那么useReducer就是一个简化版本的redux.</p>\n<p>同时，useReducer也是增强版的useState.相比于使用useState来保存哈希表， 我更倾向于使用useReducer.让数据的变化易于管理.</p>\n<ol>\n<li>定义reducer, reducer包含两个参数， state状态本身， action对state操作的行为</li>\n<li>初始化reducer, useReducer(arg1, arg2) 参数1为reducer, 参数2为数据初始化值</li>\n<li>\n<p>userReducer返回一个数组， 0为双向绑定的数据， 1为dispatch， 我们通过dispatch改变state</p>\n<pre><code class=\"language-js\">const initialState = {count: 0};\n</code></pre>\n</li>\n</ol>\n<p>// 每次操作返回一个新的state\nfunction reducer(state, action) {\nswitch (action.type) {\ncase 'increment':\nreturn {count: state.count + 1};\ncase 'decrement':\nreturn {count: state.count - 1};\ndefault:\nthrow new Error();\n}\n}</p>\n<p>function Counter() {\nconst [state, dispatch] = useReducer(reducer, initialState);\nreturn (\n&#x3C;>\nCount: {state.count}\n&#x3C;button onClick={() => dispatch({type: 'decrement'})}>-</button>\n&#x3C;button onClick={() => dispatch({type: 'increment'})}>+</button>\n&#x3C;/>\n);\n}</p>\n<pre><code>## useMemo\n运用缓存.我们写的是纯函数.如果依赖项(一般是入参)不改变，那么就从缓存中取值.useMemo(fn)立即返回结果。\n\n常见的使用手段是： 先正常写， 写完后，加入useMemo,达到性能优化的目的.\nAPI解析：\n```js\n// arg1: 必选参数： 复杂或有性能问题的计算\n// arg2: 可选参数： 如果不传则每次进行计算\nconst memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);\n</code></pre>\n<pre><code class=\"language-js\">import React, { useState, useMemo } from \"react\";\n\nconst fibonacci = n => {\n  if (n &#x3C;= 1) {\n    return 1;\n  }\n\n  return fibonacci(n - 1) + fibonacci(n - 2);\n};\n\nconst MemoComponent = () => {\n  const [num, setNum] = useState(1);\n  const [isGreen, setIsGreen] = useState(true);\n  const fib = useMemo(() => fibonacci(num), [num]);\n\n  return (\n    &#x3C;div>\n      &#x3C;h1\n        onClick={() => setIsGreen(!isGreen)}\n        style={{ color: isGreen ? \"limegreen\" : \"crimson\" }}\n      >\n        useMemo Example\n      &#x3C;/h1>\n      &#x3C;h2>\n        Fibonacci of {num} is {fib}\n      &#x3C;/h2>\n      &#x3C;button onClick={() => setNum(num + 1)}>➕&#x3C;/button>\n    &#x3C;/div>\n  );\n};\n\nexport default MemoComponent;\n</code></pre>\n<h2>useCallback</h2>\n<p>useCallback(fn, deps) 相当于 useMemo(() => fn, deps)。</p>","frontmatter":{"title":"hook基础-useRef/useCallback/useMemo/useReducer","date":"03 January, 2020","tag":"react-hook","banner":"https://desk-fd.zol-img.com.cn/t_s960x600c5/g2/M00/04/0B/ChMlWl0-oHmIDZvqAAdz3RsOKEYAAMMNwPQhEkAB3P1417.jpg"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/md/react/不常见hook/"}}}