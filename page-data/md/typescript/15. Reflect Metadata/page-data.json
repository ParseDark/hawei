{"componentChunkName":"component---src-templates-blog-post-js","path":"/md/typescript/15. Reflect Metadata/","result":{"data":{"markdownRemark":{"html":"<h1>Reflect Metadata</h1>\n<h3>概括</h3>\n<pre><code class=\"language-bash\">npm i reflect-metadata --save\n</code></pre>\n<p>之后我们就可以用装饰器来获取、添加元数据了.</p>\n<pre><code class=\"language-ts\">import \"reflect-metadata\";\n@Reflect.metadata('name', 'A')\nclass A {\n    @Reflect.metadata('hello', 'world')\n    public hello(): string {\n        return 'hello world'\n    }\n}\n\nconst log = (s: any) => console.log(s);\n\nlog(Reflect.getMetadata('name', A)) // 'A'\nlog(Reflect.getMetadata('hello', new A())) // 'undefined'\n</code></pre>\n<p>结论就是</p>\n<ol>\n<li>Relfect Metadata，可以通过装饰器来给类添加一些自定义的信息</li>\n<li>然后通过反射将这些信息提取出来</li>\n<li>也可以通过反射来添加这些信息</li>\n</ol>\n<h3>常用api</h3>\n<p>参数解释</p>\n<ol>\n<li>Metadata Key: 元数据的Key，本质上内部实现是一个Map对象，以键值对的形式储存元数据</li>\n<li>Metadata Value: 元数据的Value，这个容易理解</li>\n<li>Target: 一个对象，表示元数据被添加在的对象上</li>\n<li>Property: 对象的属性，元数据不仅仅可以被添加在对象上，也可以作用于属性，这跟装饰器类似</li>\n</ol>\n<h4>设置/获取元数据-metadata</h4>\n<ol>\n<li>\n<p>通过装饰器给目标添加元数据</p>\n<pre><code class=\"language-ts\">function metadata(\nmetadataKey: any,\nmetadataValue: any\n): {\n(target: Function): void;\n(target: Object, propertyKey: string | symbol): void;\n};\n</code></pre>\n</li>\n<li>\n<p>用 defineMetadata 来添加元数据.</p>\n<pre><code class=\"language-ts\">// define metadata on an object or property\nReflect.defineMetadata(metadataKey, metadataValue, target);\nReflect.defineMetadata(metadataKey, metadataValue, target, propertyKey);\n</code></pre>\n</li>\n<li>\n<p>获取元数据</p>\n<pre><code class=\"language-ts\">import 'reflect-metadata'\n</code></pre>\n</li>\n</ol>\n<p>@Reflect.metadata('name', 'xiaomuzhu')\nclass Person {</p>\n<pre><code>@Reflect.metadata('time', '2019/10/10')\npublic say(): string {\n    return 'hello'\n}\n</code></pre>\n<p>}</p>\n<p>console.log(Reflect.getMetadata('name', Person)) // xiaomuzhu\nconsole.log(Reflect.getMetadata('time', new Person, 'say')) // 2019/10/10</p>\n<pre><code>注意，如果元数据添加在实例方法里，那么元数据会存在实例上而不是class本身， 所以需要我们先new一个实例， 从实例上去取元数据。\n\n#### 内置元数据\n上面的例子中，我们的元数据是开发者自己设置的，其实我们也可以获取一些 TypeScript 本身内置的一些元数据。(其实我认为啊，这些元数据其实就是ts提供的类型信息.)\n\n比如，我们通过 design:type 作为 key 可以获取目标的类型\n```ts\n// 获取方法的类型\nconst type = Reflect.getMetadata(\"design:type\", new Person, 'say')\n\n// [Function: Function]\n</code></pre>\n<p>通过 design:paramtypes 作为 key 可以获取目标参数的类型</p>\n<pre><code class=\"language-ts\">// 获取参数的类型,返回数组\nconst typeParam = Reflect.getMetadata(\"design:paramtypes\", new Person, 'say')\n\n// [Function: String]\n</code></pre>\n<p>使用 design:returntype 元数据键获取有关方法返回类型的信息:</p>\n<pre><code class=\"language-ts\">const typeReturn = Reflect.getMetadata(\"design:returntype\", new Person, 'say')\n// [Function: String]\n</code></pre>\n<h3>实践</h3>\n<p> Nestjs 会有分散式的装饰器路由，比如 @Get @Post 等，正是借助 Reflect Metadata 实现的。</p>\n<p> 例如一个博客系统的路由：</p>\n<pre><code class=\"language-ts\">@Controller('/article')\nclass Home {\n    @Get('/content')\n    someGetMethod() {\n      return 'hello world';\n    }\n  \n    @Post('/comment')\n    somePostMethod() {}\n}\n</code></pre>\n<p>来实现一下.</p>\n<ol>\n<li>\n<p>我们先实现一个生产控制器 Controller 的装饰器工厂函数:</p>\n<pre><code class=\"language-ts\">const METHOD_METADATA = 'method'\nconst PATH_METADATA = 'path'\n// 装饰器工厂函数,接受路由的路径path返回一个装饰器\nconst Controller = (path: string): ClassDecorator => {\nreturn target => {\nReflect.defineMetadata(PATH_METADATA, path, target);\n}\n}\n</code></pre>\n</li>\n<li>\n<p>实现 Get Post 等方法装饰器:</p>\n<pre><code class=\"language-ts\">// 装饰器工厂函数,首先接受一个方法,比如get/post,如何再接受一个路由路径,返回一个携带了上述两个信息的装饰器\nconst createMappingDecorator = (method: string) => (path: string): MethodDecorator => {\nreturn (target, key, descriptor) => {\nReflect.defineMetadata(PATH_METADATA, path, descriptor.value!);\nReflect.defineMetadata(METHOD_METADATA, method, descriptor.value!);\n}\n}\n</code></pre>\n</li>\n</ol>\n<p>const Get = createMappingDecorator('GET');\nconst Post = createMappingDecorator('POST');</p>\n<pre><code>3. 读取整个Class中的元数据:\n```ts\nimport \"reflect-metadata\";\n\nconst METHOD_METADATA = 'method'\nconst PATH_METADATA = 'path'\n/** 工具函数 **/\n\nfunction isConstructor(symbol: any): boolean {\n    return notUndefined(symbol) &#x26;&#x26;\n        symbol instanceof Function &#x26;&#x26;\n        symbol.constructor &#x26;&#x26;\n        symbol.constructor instanceof Function &#x26;&#x26;\n        notUndefined(new symbol) &#x26;&#x26;\n        Object.getPrototypeOf(symbol) !== Object.prototype &#x26;&#x26;\n        symbol.constructor !== Object &#x26;&#x26;\n        symbol.prototype.hasOwnProperty('constructor');\n};\n\nfunction notUndefined(item: any): boolean {\n    return item != undefined &#x26;&#x26; item != 'undefined';\n}\n\nfunction isFunction(value: any): value is Function {\n    return typeof value === 'function';\n}\n\n\nfunction mapRoute(instance: Object) {\n    const prototype = Object.getPrototypeOf(instance);\n\n    // 筛选出类的 methodName\n    const methodsNames = Object.getOwnPropertyNames(prototype)\n        .filter(item => !isConstructor(item) &#x26;&#x26; isFunction(prototype[item]));\n    return methodsNames.map(methodName => {\n        const fn = prototype[methodName];\n\n        // 取出定义的 metadata\n        const route = Reflect.getMetadata(PATH_METADATA, fn);\n        const method = Reflect.getMetadata(METHOD_METADATA, fn);\n        return {\n            route,\n            method,\n            fn,\n            methodName\n        }\n    })\n};\n\nReflect.getMetadata(PATH_METADATA, Home);\n\nconst info = mapRoute(new Home());\n\nconsole.log(info);\n</code></pre>","frontmatter":{"title":"15. Reflect Metadata"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/md/typescript/15. Reflect Metadata/"}}}