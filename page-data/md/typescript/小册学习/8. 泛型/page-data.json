{"componentChunkName":"component---src-templates-blog-post-js","path":"/md/typescript/小册学习/8. 泛型/","result":{"data":{"markdownRemark":{"html":"<h1>泛型</h1>\n<h3>背景</h3>\n<p>我们现在的情况是，我们在静态编写的时候并不确定传入的参数到底是什么类型，只有当在运行时传入参数后我们才能确定。</p>\n<p>那么我们需要变量，这个变量代表了传入的类型，然后再返回这个变量，它是一种特殊的变量，只用于表示类型而不是值。</p>\n<pre><code class=\"language-ts\">function returnItem&#x3C;T>(para: T): T {\n    return para\n}\n</code></pre>\n<h3>多泛型</h3>\n<pre><code class=\"language-ts\">function swap&#x3C;T, U>(tuple: [T, U]): [U, T] {\n    return [tuple[1], tuple[0]];\n}\n\nswap([7, 'seven']); // ['seven', 7]\n</code></pre>\n<h3>泛型变量</h3>\n<pre><code class=\"language-ts\">function getArrayLength&#x3C;T>(arg: T): T {\n  console.log(arg.length) // 类型“T”上不存在属性“length”\n  return arg\n}\n</code></pre>\n<p>此时我们可以使用泛型+数组的方式来处理这种情况.</p>\n<pre><code class=\"language-ts\">function getArrayLength&#x3C;T>(arg: Array&#x3C;T>) {\n  \n  console.log((arg as Array&#x3C;any>).length) // ok\n  return arg\n}\n</code></pre>\n<h3>泛型接口</h3>\n<p>泛型也可用于接口声明，以上面的函数为例，如果我们将其转化为接口的形式。</p>\n<pre><code class=\"language-ts\">interface ReturnItemFn&#x3C;T> {\n    (para: T): T\n}\n\nconst returnItem: ReturnItemFn&#x3C;number> = para => para;\n</code></pre>\n<h3>泛型类</h3>\n<p>先来看一下number版本的例子</p>\n<pre><code class=\"language-ts\">class Stack {\n    private arr: number[] = []\n\n    public push(item: number) {\n        this.arr.push(item)\n    }\n\n    public pop() {\n        this.arr.pop()\n    }\n}\n</code></pre>\n<p>但是如果你要支持不同的类型例如： string 那么就要泛型了。</p>\n<pre><code class=\"language-ts\">class Stack&#x3C;T> {\n    private arr: T[] = []\n\n    public push(item: T) {\n        this.arr.push(item)\n    }\n\n    public pop() {\n        this.arr.pop()\n    }\n}\n</code></pre>\n<h3>泛型约束</h3>\n<p>虽然是泛型，但是是有范围的泛型.</p>\n<pre><code class=\"language-ts\">// 比如，只支持string和number的stack\ntype Params = number | string\n\nclass Stack&#x3C;T extends Params> {\n    private arr: T[] = [];\n\n    public push(item:T) {\n        this.arr.push(item);\n    } \n\n    public pop() {\n        this.arr.pop();\n    }\n}\n</code></pre>\n<h3>泛型约束与索引类型</h3>\n<p>解决一个问题，一个函数，接收两个参数，参数1为对象，参数二为对象上的key, 返回对应的value。</p>\n<pre><code class=\"language-ts\">function getValue&#x3C;T extends object, U extends keyof T>(obj: T, key: U) {\n  return obj[key] // ok\n}\n</code></pre>\n<h3>使用多重类型进行泛型约束</h3>\n<p>简而言之， 我的泛型可以对多个自定义类型进行约束， 只能在我约束范围内.</p>\n<p>其实就是用接口来对自定义类型进行继承，然后再使用.</p>\n<pre><code class=\"language-ts\">interface ChildInterface extends FirstInterface, SecondInterface {\n\n}\n\nclass Demo&#x3C;T extends ChildInterface> {\n  private genericProperty: T\n\n  useT() {\n    this.genericProperty.doSomething()\n    this.genericProperty.doSomethingElse()\n  }\n}\n</code></pre>\n<h3>泛型与 new</h3>\n<p>我们的泛型有时候需要使用new关键字</p>\n<pre><code class=\"language-ts\">function factory&#x3C;T>(type: {new(): T}): T {\n  return new type() // ok\n}\n</code></pre>","frontmatter":{"title":""}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/md/typescript/小册学习/8. 泛型/"}}}