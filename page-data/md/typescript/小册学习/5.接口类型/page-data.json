{"componentChunkName":"component---src-templates-blog-post-js","path":"/md/typescript/小册学习/5.接口类型/","result":{"data":{"markdownRemark":{"html":"<h1>接口类型</h1>\n<p>鸭子辨别法， 如果这个物体两只脚， 也会嘎嘎嘎的叫，那么就是鸭子。</p>\n<p>而接口正是这种机制。</p>\n<p>提供一个命名空间，如果符合我们对其的定义，那么都属于这个接口类型。</p>\n<h3>使用</h3>\n<p>一般用于我们函数中，自定义参数.例如：</p>\n<pre><code class=\"language-js\">const getUserName = (user) => user.name;\n</code></pre>\n<p>如果我们基于ts，那么以上代码会报错.此时我们就需要一个自定义的接口类型来描述这种类型。</p>\n<pre><code class=\"language-ts\">interface User {\n    name: string\n    age: number\n    isMale: boolean\n}\n\nconst getUserName = (user: User) => user.name\n</code></pre>\n<h3>可选属性</h3>\n<pre><code class=\"language-ts\">interface User{\n    name: string\n    age?: number\n}\n</code></pre>\n<h3>只读</h3>\n<pre><code class=\"language-ts\">interface User{\n    name: string\n    age?: number\n    readonly isMale: boolean\n}\n</code></pre>\n<h3>函数类型</h3>\n<pre><code class=\"language-ts\">// method1: direct description\ninterface User {\n    name: string\n    age?: number\n    readonly isMale: boolean\n    say: (words: string) => string\n}\n\n// method2: use interface description func\ninterface Say {\n    (words: string) : string\n}\n\ninterface User {\n    name: string\n    age?: number\n    readonly isMale: boolean\n    say: Say\n}\n</code></pre>\n<h3>属性检查</h3>\n<pre><code class=\"language-ts\">interface Config {\n  width?: number;\n}\n\nfunction  CalculateAreas(config: Config): { area: number} {\n  let square = 100;\n  if (config.width) {\n      square = config.width * config.width;\n  }\n  return {area: square};\n}\n\nlet mySquare = CalculateAreas({ widdth: 5 });\n</code></pre>\n<p>注意，在我们使用calculateareas的时候，我们传入的并不是config接口类型（而是widdth），这个时候，ts认为我们的代码是有问题的.</p>\n<p>在这种情况下，ts提供2种方法去解决</p>\n<ol>\n<li>\n<p>类型断言</p>\n<pre><code class=\"language-ts\">let mySquare = CalculateAreas({ widdth: 5 } as Config);\n</code></pre>\n</li>\n<li>\n<p>第二种添加字符串索引签名</p>\n<pre><code class=\"language-ts\">interface Config {\nwidth?: number;\n// 任意数量，任意类型\n[propName: string]: any;\n}\n</code></pre>\n</li>\n</ol>\n<h3>可索引类型</h3>\n<p>描述相似的数据类型， 有点像上面说的字符串索引签名.</p>\n<pre><code class=\"language-ts\">{\n    name: 'xiaozhang',\n    age: 18,\n    isMale: false,\n    say: Function,\n    phone: {\n        NetEase: 'xiaozhang@163.com',\n        qq: '1845751425@qq.com',\n    }\n}\n\n{\n    name: 'xiaoming',\n    age: 16,\n    isMale: true,\n    say: Function,\n    phone: {\n        NetEase: 'xiaoming@163.com',\n        qq: '784536325@qq.com',\n        sina: 'abc784536325@sina.com',\n    }\n}\n// 对于phone这个field, 有些不一样，但是我们对它的描述就可以使用可索引类型\ninterface Phone {\n    [name: string]: string\n}\n\ninterface User {\n    name: string\n    age?: number\n    readonly isMale: boolean\n    say: () => string\n    phone: Phone\n}\n</code></pre>\n<h3>继承接口</h3>\n<p>接口可以互相继承.增加代码的可复用性.</p>\n<pre><code class=\"language-ts\">interface VIPUser extends User, SupperUser {\n    broadcast: () => void\n}\n</code></pre>","frontmatter":{"title":""}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/md/typescript/小册学习/5.接口类型/"}}}