{"componentChunkName":"component---src-templates-blog-post-js","path":"/md/typescript/小册学习/4. 枚举类型/","result":{"data":{"markdownRemark":{"html":"<h1>枚举类型</h1>\n<p>枚举类型是很多语言都拥有的类型,它用于声明一组命名的常数,当一个变量有几种可能的取值时,可以将它定义为枚举类型。</p>\n<ul>\n<li>数字枚举</li>\n<li>字符串枚举</li>\n<li>异构枚举</li>\n<li>反向映射</li>\n<li>枚举的本质</li>\n<li>常量枚举</li>\n<li>联合枚举和枚举成员类型</li>\n<li>联合枚举</li>\n<li>枚举合并</li>\n<li>为枚举添加静态方法</li>\n</ul>\n<h3>数字枚举</h3>\n<p>如果我们定义一个枚举类型， 没初始化，那么就是数字枚举类型。</p>\n<pre><code class=\"language-ts\">enum dir {\n    up,\n    down,\n    left,\n    right,\n}\n\nconsole.log(dir.up === 0)\nconsole.log(dir.down === 1)\nconsole.log(dir.left === 2)\nconsole.log(dir.right === 3)\n</code></pre>\n<p>当我制定了第一个值，那么后面的都会往下累加</p>\n<h3>字符串枚举</h3>\n<p>字符串和数据枚举类型可以同时存在.</p>\n<pre><code class=\"language-ts\">enum Direction {\n    Up = 'Up',\n    Down = 'Down',\n    Left = 'Left',\n    Right = 'Right'\n}\n</code></pre>\n<h3>异构枚举</h3>\n<p>一个枚举内存在不同的类型</p>\n<pre><code class=\"language-ts\">enum BooleanLikeHeterogeneousEnum {\n    No = 0,\n    Yes = \"YES\",\n}\n</code></pre>\n<h3>反向映射</h3>\n<p>枚举类型是双向映射的， 你可以通过key=>value, 也可以通过value=>key</p>\n<p>如果你给两个不同的枚举key取一样的value呢？是可以的，此时你通过value=>key只是最后一个.</p>\n<h3>枚举的本质</h3>\n<p>枚举结构是一个对象，但是由于其特殊的结构，让她可以双向映射.</p>\n<pre><code class=\"language-js\">var Direction;\n(function (Direction) {\n    Direction[Direction[\"Up\"] = 10] = \"Up\";\n    Direction[Direction[\"Down\"] = 11] = \"Down\";\n    Direction[Direction[\"Left\"] = 12] = \"Left\";\n    Direction[Direction[\"Right\"] = 13] = \"Right\";\n})(Direction || (Direction = {}));\n\nconsole.log(Direction[10], Direction['Right']); // Up 13\n</code></pre>\n<h3>常量枚举</h3>\n<p>枚举可以赋值给常量.</p>\n<pre><code class=\"language-ts\">const enum Direction {\n    Up = 'Up',\n    Down = 'Down',\n    Left = 'Left',\n    Right = 'Right'\n}\n\nconst a = Direction.Up;\n\n// 编译后\nvar a = \"Up\";\n</code></pre>\n<p>这就是常量枚举的作用,因为下面的变量 a 已经使用过了枚举类型,之后就没有用了,也没有必要存在与 JavaScript 中了, TypeScript 在这一步就把 Direction 去掉了,我们直接使用 Direction 的值即可,这是性能提升的一个方案。</p>\n<h3>联合枚举与枚举成员的类型</h3>\n<p>枚举成员都存在自己的类型例如</p>\n<pre><code class=\"language-ts\">// string\nconst enum D {\n    up = 'up',\n    down = 'down'\n}\n\n// number\nconst enum n {\n    up,\n    down\n}\n// -\nconst enum n {\n    up = -1,\n    down = -2\n}\n</code></pre>\n<h3>枚举合并</h3>\n<pre><code class=\"language-ts\">enum Direction {\n    Up = 'Up',\n    Down = 'Down',\n    Left = 'Left',\n    Right = 'Right'\n}\n\nenum Direction {\n    Center = 1\n}\n// 在编译的时候会自动把两者合并\n</code></pre>\n<h3>为枚举添加静态方法</h3>\n<p>借助 namespace 命名空间，我们甚至可以给枚举添加静态方法。</p>\n<pre><code class=\"language-ts\">// 例如我现在有十二月份的枚举类型\nenum Month {\n    January,\n    February,\n    March,\n    April,\n    May,\n    June,\n    July,\n    August,\n    September,\n    October,\n    November,\n    December,\n}\n// 找出夏天的月份\nfunction isSummer(month: Month) {\n    switch (month) {\n        case Month.June:\n        case Month.July:\n        case Month.August:\n            return true;\n        default:\n            return false\n    }\n}\n// 那么结合这两者，就需要枚举的命名空间的力量了\nnamespace Month {\n    export function isSummer(month: Month) {\n        switch (month) {\n            case Month.June:\n            case Month.July:\n            case Month.August:\n                return true;\n            default:\n                return false\n        }\n    }\n}\n\nconsole.log(Month.isSummer(Month.January)) // false\n</code></pre>","frontmatter":{"title":""}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/md/typescript/小册学习/4. 枚举类型/"}}}