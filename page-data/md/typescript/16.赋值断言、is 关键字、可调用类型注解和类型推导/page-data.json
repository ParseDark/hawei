{"componentChunkName":"component---src-templates-blog-post-js","path":"/md/typescript/16.赋值断言、is 关键字、可调用类型注解和类型推导/","result":{"data":{"markdownRemark":{"html":"<h1>赋值断言、is 关键字、可调用类型注解和类型推导</h1>\n<h3>明确赋值断言</h3>\n<p>TypeScript 2.7 引入了一个新的控制严格性的标记: --strictPropertyInitialization</p>\n<p>它的作用就是保证变量声明和实例属性都会有初始值:</p>\n<pre><code class=\"language-ts\">class StrictClass {\n    foo: number;\n    bar = 'hello';\n    baz: boolean; // 属性“baz”没有初始化表达式，且未在构造函数中明确赋值\n    constructor() {\n        this.foo = 42;\n    }\n}\n</code></pre>\n<ol>\n<li>该属性本来就可以是 undefined，这种情况下添加类型undefined</li>\n<li>属性被间接初始化了（例如构造函数中调用一个方法，更改了属性的值）</li>\n</ol>\n<p>例如： </p>\n<pre><code class=\"language-ts\">let x: number;\ninitialize();\nconsole.log(x + x); // 在赋值前使用了变量“x”。ts(2454)\nfunction initialize() {\n    x = 10;\n}\n</code></pre>\n<p>会报错，没有赋值就使用x。但是我们已经通过函数initialize隐式赋值了。</p>\n<pre><code class=\"language-ts\">let x: number;\ninitialize();\nconsole.log(x! + x!); //ok\n\nfunction initialize() {\n    x = 10;\n}\n</code></pre>\n<h3>is关键字</h3>\n<p>判定是否属于某种类型.然后返回布尔值.\n例如：</p>\n<pre><code class=\"language-ts\">export function foo(arg: string): arg is MyType {\n    return ...\n}\n\nfunction isString(test: any): test is string{\n    return typeof test === 'string';\n}\n\nfunction example(foo: number | string){\n    if(isString(foo)){\n        console.log('it is a string' + foo);\n        console.log(foo.length); // string function\n    }\n}\nexample('hello world');\n</code></pre>\n<h3>可调用类型注解</h3>\n<p>我们已经可以用静态类型注解我们的函数、参数等等，但是假设我们有一个接口，我们如何操作才能让它被注解为可执行的:</p>\n<pre><code class=\"language-ts\">interface ToString {\n  \n}\n\ndeclare const sometingToString: ToString;\n\nsometingToString() // This expression is not callable. Type 'ToString' has no call signatures.ts(2349)\n</code></pre>\n<p>我们必须用一种方法让编译器知道这个是可调用的，我们可以这样：</p>\n<pre><code class=\"language-ts\">interface ToString {\n  (): string\n}\n\ndeclare const sometingToString: ToString;\n\nsometingToString() // ok\n</code></pre>\n<p>接口实例化， 用new调用</p>\n<pre><code class=\"language-ts\">interface ToString {\n  (): string\n}\n\ndeclare const sometingToString: ToString;\n\nnew sometingToString() // 其目标缺少构造签名的 \"new\" 表达式隐式具有 \"any\" 类型\n</code></pre>\n<p>所以此时需要我们使用new表示该接口可以实例化</p>\n<pre><code class=\"language-ts\">interface ToString {\n  new (): string\n}\n\ndeclare const sometingToString: ToString;\n\nnew sometingToString() // ok\n</code></pre>\n<h3>类型推导</h3>\n<p>额 就是提供了隐式推导机制.</p>","frontmatter":{"title":"16.赋值断言、is 关键字、可调用类型注解和类型推导","date":"03 January, 2020","tag":"typescript","banner":"https://desk-fd.zol-img.com.cn/t_s960x600c5/g2/M00/04/0B/ChMlWl0-oHmIDZvqAAdz3RsOKEYAAMMNwPQhEkAB3P1417.jpg"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/md/typescript/16.赋值断言、is 关键字、可调用类型注解和类型推导/"}}}