{"componentChunkName":"component---src-templates-blog-post-js","path":"/md/typescript/14.高级装饰器/","result":{"data":{"markdownRemark":{"html":"<h1>高级装饰器</h1>\n<p>上一节说的基本的装饰器： : 类装饰器、属性装饰器、方法装饰器、访问符装饰器.</p>\n<p>这一节说的是非常用的，但是在基础库里用得很多的高级装饰器.</p>\n<h3>参数装饰器</h3>\n<p>参数装饰器，顾名思义是用于修饰参数的装饰器。</p>\n<p><strong>参数详解</strong></p>\n<ol>\n<li>target —— 当前对象的原型，也就是说，假设 Person 是当前对象，那么当前对象 target 的原型就是 Person.prototype</li>\n<li>propertyKey —— 参数的名称，上例中指的就是 greet</li>\n<li>\n<p>index —— 参数数组中的位置，比如上例中参数 name 的位置是 1, message 的位置为 0</p>\n<pre><code class=\"language-ts\">function logParameter(target: Object, propertyKey: string, index: number) {\nconsole.log(target, propertyKey, index);\n}\n</code></pre>\n</li>\n</ol>\n<p>class Person {\ngreet(@logParameter message: string,@logParameter name: string): string {\nreturn <code>${message} ${name}</code>;\n}\n}\nconst p = new Person();\np.greet('hello', 'xiaomuzhu');</p>\n<p>// Person { greet: [Function] } greet 1\n// Person { greet: [Function] } greet 0</p>\n<pre><code>// 没看懂\n参数装饰器可以提供信息，给比如给类原型添加了一个新的属性，属性中包含一系列信息，这些信息就被成为「元数据」，然后我们就可以使用另外一个装饰器来读取「元数据」。\n\n### 装饰器工厂\n装饰器工厂就是一个简单的函数，它返回一种类型的装饰器。\n\n我们先假设这样一个场景，比如我们需要几个装饰器，分别把一个类中的部分属性、类本身、方法、参数的名称打印出来，我们应该怎么做?\n\n写四个肯定是可以的，只是不优雅.\n```ts\nfunction log(...args : any[]) {\n  switch(args.length) {\n    case 1:\n      return logClass.apply(this, args);\n    case 2:\n      return logProperty.apply(this, args);\n    case 3:\n      if(typeof args[2] === \"number\") {\n        return logParameter.apply(this, args);\n      }\n      return logMethod.apply(this, args);\n    default:\n      throw new Error(\"Decorators are not valid here!\");\n  }\n}\n</code></pre>\n<h3>装饰器顺序</h3>\n<p>同一行</p>\n<pre><code class=\"language-ts\">@f @g x\n</code></pre>\n<p>换行</p>\n<pre><code class=\"language-ts\">@f\\n\n@g\nx\n</code></pre>\n<p>多个装饰器的行为：</p>\n<ol>\n<li>由上至下依次对装饰器表达式求值。</li>\n<li>求值的结果会被当作函数，由下至上依次调用。</li>\n</ol>\n<p>例如：</p>\n<pre><code class=\"language-ts\">function f() {\n    console.log(\"f(): evaluated\");\n    return function (target, propertyKey: string, descriptor: PropertyDescriptor) {\n        console.log(\"f(): called\");\n    }\n}\n\nfunction g() {\n    console.log(\"g(): evaluated\");\n    return function (target, propertyKey: string, descriptor: PropertyDescriptor) {\n        console.log(\"g(): called\");\n    }\n}\n\nclass C {\n    @f()\n    @g()\n    method() {}\n}\n// console\n// f(): evaluated\n// g(): evaluated\n// g(): called\n// f(): called\n</code></pre>\n<p>类中不同声明上的装饰器将按以下规定的顺序应用：</p>\n<ol>\n<li>参数装饰器，然后依次是方法装饰器，访问符装饰器，或属性装饰器应用到每个实例成员。</li>\n<li>参数装饰器，然后依次是方法装饰器，访问符装饰器，或属性装饰器应用到每个静态成员。</li>\n<li>参数装饰器应用到构造函数。</li>\n<li>类装饰器应用到类。</li>\n</ol>","frontmatter":{"title":"14.高级装饰器","date":"03 January, 2020","tag":"typescript","banner":"https://desk-fd.zol-img.com.cn/t_s960x600c5/g2/M00/04/0B/ChMlWl0-oHmIDZvqAAdz3RsOKEYAAMMNwPQhEkAB3P1417.jpg"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/md/typescript/14.高级装饰器/"}}}