{"componentChunkName":"component---src-templates-blog-post-js","path":"/md/typescript/11. 高级类型之交叉类型、联合类型、类型别名/","result":{"data":{"markdownRemark":{"html":"<h1>高级类型之交叉类型、联合类型、类型别名</h1>\n<p>基础组块之上的知识了.</p>\n<h3>交叉类型</h3>\n<p>对于交叉类型，把现有的类型进行叠加形成一种新的类型.包含叠加类型的特性.</p>\n<p>在js中我们有mixin操作， 就是把两个对象mixin成一个新对象，这个对象有这两个对象的特性.</p>\n<p>而交叉类型可以让你完成这个操作.</p>\n<pre><code class=\"language-ts\">// T &#x26; U 这种类型拥有T和u的特性\ninterface IAnyObject {\n    [prop: string]: any\n}\n\nfunction mixin&#x3C;T extends IAnyObject, U extends IAnyObject>(first: T, second: U): T &#x26; U {\n    const result = &#x3C;T &#x26; U>{};\n    for (let id in first) {\n      (&#x3C;T>result)[id] = first[id];\n    }\n    for (let id in second) {\n      if (!result.hasOwnProperty(id)) {\n        (&#x3C;U>result)[id] = second[id];\n      }\n    }\n  \n    return result;\n  }\n  \n  const x = mixin({ a: 'hello' }, { b: 42 });\n  \n  // 现在 x 拥有了 a 属性与 b 属性\n  const a = x.a;\n  const b = x.b;\n</code></pre>\n<h3>联合类型</h3>\n<p>我觉得这个概念和带约束的泛型很像.就是用“|”分割就好.</p>\n<pre><code class=\"language-ts\">function formatCommandline(command: string[] | string) {\n  let line = '';\n  if (typeof command === 'string') {\n    line = command.trim();\n  } else {\n    line = command.join(' ').trim();\n  }\n}\n</code></pre>\n<h3>类型别名</h3>\n<p>这个我们其实在泛型那章已经见过了.就是基于现有类型，自定义新的类型.</p>\n<pre><code class=\"language-ts\">// 联合类型\ntype some = boolean | string\n\nconst b: some = true // ok\nconst c: some = 'hello' // ok\nconst d: some = 123 // 不能将类型“123”分配给类型“some”\n\n// 泛型\ntype Container&#x3C;T> = { value: T };\n</code></pre>\n<p>与interface的区别.</p>\n<ol>\n<li>interface 只能用于定义对象类型，而 type 的声明方式除了对象之外还可以定义交叉、联合、原始类型等，类型声明的方式适用范围显然更加广泛。</li>\n</ol>","frontmatter":{"title":"11. 高级类型之交叉类型、联合类型、类型别名","date":"03 January, 2020","tag":"typescript","banner":"https://desk-fd.zol-img.com.cn/t_s960x600c5/g2/M00/04/0B/ChMlWl0-oHmIDZvqAAdz3RsOKEYAAMMNwPQhEkAB3P1417.jpg"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/md/typescript/11. 高级类型之交叉类型、联合类型、类型别名/"}}}