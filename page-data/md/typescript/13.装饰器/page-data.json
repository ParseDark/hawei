{"componentChunkName":"component---src-templates-blog-post-js","path":"/md/typescript/13.装饰器/","result":{"data":{"markdownRemark":{"html":"<h1>装饰器</h1>\n<p>解决了什么问题？</p>\n<p>装饰器(decorator)最早在 Python 中被引入,它的主要作用是给一个已有的方法或类扩展一些新的行为，而不是去直接修改它本身.</p>\n<p>两个概念： </p>\n<ol>\n<li>目前装饰器本质上是一个函数,@expression 的形式其实是一个语法糖, expression 求值后必须也是一个函数，它会在运行时被调用，被装饰的声明信息做为参数传入.</li>\n<li>JavaScript 中的 Class 其实也是一个prototype语法糖</li>\n</ol>\n<h3>类装饰器</h3>\n<p>在一个person类增加一个装饰器去给class属性添加age年龄属性.</p>\n<p>那我理解，装饰器其实就是在实例化的时候往我们的class上的prototype属性上加东西.</p>\n<pre><code class=\"language-ts\">function addAge(constructor: Function) {\n  constructor.prototype.age = 18;\n}\n\n@addAge\nclass Person{\n  name: string;\n  age: number;\n  constructor() {\n    this.name = 'xiaomuzhu';\n  }\n}\n\nlet person = new Person();\n\nconsole.log(person.age); // 18\n</code></pre>\n<p>等价于</p>\n<pre><code class=\"language-js\">Person = addAge(function Person() { ... });\n</code></pre>\n<h3>属性/方法装饰器</h3>\n<p>实际上一个Class的属性/方法也可以被装饰,我们分别给 Person 类加上 say 和 run 方法.</p>\n<p>注意，方法装饰器只是在初始化的时候会去执行.</p>\n<pre><code class=\"language-ts\">// 声明装饰器修饰方法/属性\n// 在属性/方法的装饰器定义过程中,与 class 的装饰器不同,我们的 method 函数中的参数变为了三个 target、propertyKey、descriptor.\n// 装饰器的运作基于Object.defineProperty\nfunction method(target: any, propertyKey: string, descriptor: PropertyDescriptor) {\n   console.log(target);\n   console.log(\"prop \" + propertyKey);\n   console.log(\"desc \" + JSON.stringify(descriptor) + \"\\n\\n\");\n   descriptor.writable = false;\n};\n\nclass Person{\n  name: string;\n  constructor() {\n    this.name = 'xiaomuzhu';\n  }\n\n  @method\n  say(){\n    return 'instance method';\n  }\n\n  @method\n  static run(){\n    return 'static method';\n  }\n}\n\nconst xmz = new Person();\n\n// 修改实例方法say\nxmz.say = function() {\n  return 'edit'\n}\n\n// 打印结果,检查是否成功修改实例方法\nconsole.log(xmz.say());\n</code></pre>\n<p>上面的代码等同于</p>\n<pre><code class=\"language-js\">let descriptor = {\n    value: function() { return 'instance method'},\n    enumerable: false,\n    configurable: true,\n    writable: true\n};\n\ndescriptor = readonly(Cat.prototype, \"say\", descriptor) || descriptor;\n\nObject.defineProperty(Cat.prototype, \"say\", descriptor);\n</code></pre>\n<p>既然本质上是操作defineProperty, 那么我们可以对get/set方法进行操作.</p>","frontmatter":{"title":"13.装饰器"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/md/typescript/13.装饰器/"}}}