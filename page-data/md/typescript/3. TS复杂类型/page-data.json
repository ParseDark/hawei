{"componentChunkName":"component---src-templates-blog-post-js","path":"/md/typescript/3. TS复杂类型/","result":{"data":{"markdownRemark":{"html":"<h1>比较复杂的类型</h1>\n<ul>\n<li>any</li>\n<li>unknown</li>\n<li>never</li>\n<li>object</li>\n<li>数组/元祖</li>\n</ul>\n<h3>any</h3>\n<p>anyScript</p>\n<h3>unknown</h3>\n<p>和any很像，与 any 的不同之处,虽然它们都可以是任何类型,但是当 unknown 类型被确定是某个类型之前,它不能被进行任何操作比如实例化、getter、函数执行等等。</p>\n<pre><code class=\"language-ts\">// any\nlet value: any;\n\nvalue.foo.bar;  // OK\nvalue();        // OK\nnew value();    // OK\nvalue[0][1];    // OK\n// unknown\nlet value: unknown;\n\nvalue.foo.bar;  // ERROR\nvalue();        // ERROR\nnew value();    // ERROR\nvalue[0][1];    // ERROR\n</code></pre>\n<h3>never</h3>\n<p>never 类型表示的是那些永不存在的值的类型，never 类型是任何类型的子类型，也可以赋值给任何类型；然而，没有类型是 never 的子类型或可以赋值给 never 类型（除了never本身之外）。\n常见实例：</p>\n<pre><code class=\"language-ts\">// 抛出异常的函数永远不会有返回值\nfunction error(message: string): never {\n    throw new Error(message);\n}\n\n// 空数组，而且永远是空的\nconst empty: never[] = []\n</code></pre>\n<h3>数组</h3>\n<p>两种方式</p>\n<pre><code class=\"language-ts\">const list: Array&#x3C;number> = [1, 2, 3]\n\nconst list: number[] = [1, 2, 3]\n</code></pre>\n<h3>元组</h3>\n<p>数组的子集，只有两个元素， 元素可不为同一类型.</p>\n<pre><code class=\"language-ts\">let x: [string, number];\n</code></pre>\n<p>元组是严格版本的数组</p>\n<pre><code class=\"language-ts\">interface Tuple extends Array&#x3C;string | number> {\n  0: string;\n  1: number;\n  length: 2;\n}\n</code></pre>\n<h3>Object</h3>\n<p>非原始类型（number，string，boolean，symbol，null 或 undefined）</p>\n<pre><code class=\"language-ts\">// 这是下一节会提到的枚举类型\nenum Direction {\n    Center = 1\n}\n\nlet value: object\n\nvalue = Direction\nvalue = [1]\nvalue = [1, 'hello']\nvalue = {}\n</code></pre>","frontmatter":{"title":"3. TS复杂类型"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/md/typescript/3. TS复杂类型/"}}}