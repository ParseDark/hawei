{"componentChunkName":"component---src-templates-blog-post-js","path":"/md/fetch/","result":{"data":{"markdownRemark":{"html":"<p>背景：项目中我们使用koa2作为静态资源+转发代理服务器.前端react.</p>\n<p>冲突：后端对于某些业务逻辑执着于状态返回500/400， 而不是使用统一的错误码， 我们又必须拿到错误信息.\n我们在koa2使用的fetch库为：request-promise-native. 一个promise请求库的实现.这个库的特点在于，</p>\n<ol>\n<li>请求数据后自动解析</li>\n<li>返回一个promise</li>\n<li>遇到非200-300自动抛出错误</li>\n</ol>\n<p>由于我们前端从koa2走了一层转发，基于request-promise-native库的特性， 那么对于后端返回的500/400此时被当作错误抛出。我们前端此时拿到了只有500， 和一个server error.于是和leader商量了一下，作出以下决定：</p>\n<ol>\n<li>\n<p>后端返回统一格式：</p>\n<pre><code class=\"language-json\">{\n\"code\": \"int\",\n\"body\": \"Object\"\n// other info\n}\n</code></pre>\n</li>\n<li>koa2层抛弃request-promise-native.统一使用标准的fetch实现.</li>\n<li>封装统一的错误处理（主要是前端， koa2主要做日志记录）</li>\n</ol>\n<p>经过技术调研，我们选择了node-fetch这个第三方实现.达到了在node端实现了fetch的功能。当然也会存在一些不一致，在github主页也已经提出.\n<a href=\"https://github.com/bitinn/node-fetch/blob/master/LIMITS.md\">已知差异</a></p>\n<p>技术选型确定就是确定feature的范围，除了本身的fetch的标准功能还包括以下feature:</p>\n<ol>\n<li>支持https的rejectUnauthorized</li>\n<li>给出默认的content-type</li>\n<li>集成日志： 请求耗时/请求记录/请求详细信息/请求错误</li>\n<li>返回数据解析为：json/text/form/blob</li>\n</ol>\n<h3>支持https的rejectUnauthorized</h3>\n<p>为什么要支持...因为我们的基础建设没有做好.  <a href=\"https://yongqiang.live/javascript/node-fetch/\">解决方案</a></p>\n<p>在issus上也有相关的讨论，不在赘述\n<a href=\"https://github.com/bitinn/node-fetch/issues/453\">issus</a></p>\n<h3>给出默认的content-type</h3>\n<p>思路很简单，判定请求类型和请求参数的content-type字段， 如果有content-type那么优先选择用户自定的content-type， 如果没有给则根据请求类型给defautl content-type.</p>\n<h3>集成日志</h3>\n<p>这个很关键，因为我们在服务端之间又隔了一层，我们就要做日志，万一出问题方便debug， 留下解题信息，我们用的是winston，大部分都用这个吧.这个就是在封装fetch不同阶段去打印日志，没啥难度， 怎么选择看大家.</p>\n<h3>返回数据解析</h3>\n<p>这个就是在content-type确定后我们就可以知道默认要解析的response的类型是什么，可以把这一步做了，把最后结果直接返回.<del>（但是这里我有个疑问，是否真的需要这个步骤，因为在koa2我们返回给前端的还是没解析过的数据啊.但我不可以直接在koa2层把response直接丢给前端， 返回的body好像有问题， ctx.body好像不能接收一个stream。）</del> 直接把返回的response转成buffer往前端丢就可以了。</p>\n<p>代码如下：\n前端也可以用，只不过要去掉日志部分，并且把解析那部分加上去，在再handleRes上做错误捕获， 和对应的错误处理即可.</p>\n<pre><code class=\"language-js\">const fetch = require('node-fetch');\nconst logger = require('winston');\nconst uniqid = require('uniqid');\n// node-fetch use rejectUnauthorized option : https://yongqiang.live/javascript/node-fetch/\n// Difference from client-side fetch : https://github.com/bitinn/node-fetch/blob/master/LIMITS.md\nconst https = require(\"https\");\nconst agent = new https.Agent({\n    rejectUnauthorized: false\n})\n\nconst HttpMethod = {\n    post: 'POST',\n    get: 'GET',\n    put: 'PUT',\n    patch: 'PATCH',\n    delete: 'DELETE',\n}\n\nconst ContentType = {\n    json: 'application/json;charset=UTF-8',\n    form: 'application/x-www-form-urlencoded; charset=UTF-8'\n}\n\n// request time log\n// 1. next() init timer\n// 2. next() start timeStamp\n// 3. next() end timeStamp\nconst timerStep = function* (id, url) {\n    yield;\n    const start = new Date();\n    logger.info(\n        `Request\\t#${id}\\t@${start.toISOString()}\\t${url}`\n    );\n    yield;\n    const end = new Date();\n    const delta = end.getTime() - start.getTime();\n    logger.info(`Response\\t#${id}\\t@${end.toISOString()}\\t△${delta}ms`);\n}\n\nconst fetchF = async (url, config = { headers: {} }) => {\n    let promise, contentTypeValue;\n    const id = uniqid();\n    const timer = timerStep(id, url);\n    timer.next();\n    const isHttps = new URL(url).protocol === \"https:\";\n\n    // set default Content-Type\n    let contentType = config &#x26;&#x26; config.headers &#x26;&#x26; config.headers[\"Content-Type\"];\n    if (contentType) {\n        contentTypeValue = config['Content-Type'];\n    } else if (config.method === HttpMethod.post) {\n        contentTypeValue = ContentType.form;\n    } else {\n        contentTypeValue = ContentType.json;\n    }\n\n    const headers = {\n        ...config.headers,\n        'Content-Type': contentTypeValue,\n    }\n\n    logger.info(\n        `header is ${JSON.stringify(headers)}`\n    );\n    timer.next();\n\n    console.log('\"Request body: \"', JSON.stringify(config.body));\n\n    if (!config.method || config.method === HttpMethod.get) {\n        promise = await fetch(url, {\n            headers,\n            agent: isHttps ? agent : false,\n        });\n    } else if (config.method === HttpMethod.post) {\n        promise = await fetch(url, {\n            body: JSON.stringify(config.body),\n            headers,\n            method: HttpMethod.post,\n            agent: isHttps ? agent : false,\n        });\n    } else {\n        promise = await fetch(url, {\n            body: JSON.stringify(config.body),\n            headers,\n            method: config.method,\n            agent: isHttps ? agent : false,\n        });\n    }\n\n    timer.next();\n    return promise.buffer();\n}\n\nconst parseRes = async (res) => {\n    const contentType = res.headers.get('Content-Type');\n    if (contentType) {\n        if (contentType.indexOf('json') > -1) {\n            return res.json();\n        }\n        if (contentType.indexOf('text') > -1) {\n            return res.text();\n        }\n        if (contentType.indexOf('form') > -1) {\n            return res.formData();\n        }\n        if (contentType.indexOf('video') > -1) {\n            return res.blob();\n        }\n    }\n    return res.text;\n}\n\nconst handleRes = async (res) => {\n    const parsedRes = await parseRes(res);\n    return parsedRes;\n    // if (res.ok) {\n    //     return parsedRes;\n    // }\n    // const err = parsedRes;\n    // throw err;\n}\n\nmodule.exports = fetchF;\n</code></pre>\n<p>另外这个小姐姐的ts封装fetch是关键啊：\n<a href=\"https://juejin.im/post/5bed21e36fb9a049b77fee1f\">fetch简单封装(基于ts)</a></p>","frontmatter":{"title":"基于node-fetch二次封装"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/md/fetch/"}}}