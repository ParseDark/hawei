{"componentChunkName":"component---src-templates-blog-post-js","path":"/md/es6/es6/","result":{"data":{"markdownRemark":{"html":"<h2>Object.entries</h2>\n<p>入参： 对象\n作用： 获取对象的枚举属性， 并且返回一个数组，数组包含一个二元组\n注意： 原型链上的key-value不可枚举</p>\n<pre><code class=\"language-js\">// 基本栗子\nconst obj = { foo: 'bar', baz: 42 };\nconsole.log(Object.entries(obj)); // [ ['foo', 'bar'], ['baz', 42] ]\n\n// property上不可枚举, 设置枚举属性为false的key不可枚举\n// getFoo is property which isn't enumerable\nconst myObj = Object.create({}, { getFoo: { value() { return this.foo; } } });\nmyObj.foo = 'bar';\nconsole.log(Object.entries(myObj)); // [ ['foo', 'bar'] ]\n\n// 把object转换成map\nvar obj = { foo: \"bar\", baz: 42 }; \nvar map = new Map(Object.entries(obj));\nconsole.log(map); // Map { foo: \"bar\", baz: 42 }\n</code></pre>\n<h2>Map</h2>\n<p>Map保存键值对.</p>\n<p>语法</p>\n<pre><code class=\"language-js\">// iterabel: 可迭代对象\nnew Map([iterable])\n</code></pre>\n<p>特征：</p>\n<ol>\n<li>可以使用for..of遍历Map</li>\n<li>key值不相等</li>\n</ol>\n<p>Object和Map区别</p>\n<ol>\n<li>Object的key只能是字符串或者Symbol, 但是Map则可以是任意值</li>\n<li>Map的值是有序的，返回的顺序是根据插入顺序， 而增加到对象上的key则是无序的</li>\n<li>你可以通过 size 属性直接获取一个 Map 的键值对个数，而 Object 的键值对个数只能手动计算。</li>\n<li>Map 可直接进行迭代，而 Object 的迭代需要先获取它的键数组，然后再进行迭代。</li>\n<li>Object 都有自己的原型，原型链上的键名有可能和你自己在对象上的设置的键名产生冲突。虽然 ES5 开始可以用 map = Object.create(null) 来创建一个没有原型的对象，但是这种用法不太常见。</li>\n<li>Map 在涉及频繁增删键值对的场景下会有些性能优势。</li>\n</ol>\n<h3>方法</h3>\n<ol>\n<li>Map.prototype.clear(): 移除所有key-value</li>\n<li>Map.prototype.delete(key): 删除key这一条属性， 如果存在， 返回true, 不存在返回false</li>\n<li>\n<p>Map.entries(): 返回一个新的 Iterator 对象，它按插入顺序包含了Map对象中每个元素的 [key, value] 数组。</p>\n<pre><code class=\"language-js\">var myMap = new Map();\nmyMap.set(\"0\", \"foo\");\nmyMap.set(1, \"bar\");\nmyMap.set({}, \"baz\");\n</code></pre>\n</li>\n</ol>\n<p>var mapIter = myMap.entries();</p>\n<p>console.log(mapIter.next().value); // [\"0\", \"foo\"]\nconsole.log(mapIter.next().value); // [1, \"bar\"]\nconsole.log(mapIter.next().value); // [Object, \"baz\"]</p>\n<pre><code>4. Map.prototype.forEach(callbackFn(, thisArg)): 按插入顺序，为 Map对象里的每一键值对调用一次callbackFn函数。如果为forEach提供了thisArg，它将在每次回调中作为this值。\n```js\nfunction logMapElements(value, key, map) {\n    console.log(\"m[\" + key + \"] = \" + value);\n}\nMap([[\"foo\", 3], [\"bar\", {}], [\"baz\", undefined]]).forEach(logMapElements);\n// logs:\n// \"m[foo] = 3\"\n// \"m[bar] = [object Object]\"\n// \"m[baz] = undefined\"\n</code></pre>\n<ol start=\"5\">\n<li>Map.prototype.get: 根据key获取value</li>\n<li>Map.prototype.has: 判断一个key是否存在Map中</li>\n<li>\n<p>Map.prototype.keys: 包含map中所有的keys, 按插入顺序排序</p>\n<pre><code class=\"language-js\">var myMap = new Map();\nmyMap.set(\"0\", \"foo\");\nmyMap.set(1, \"bar\");\nmyMap.set({}, \"baz\");\n</code></pre>\n</li>\n</ol>\n<p>var mapIter = myMap.keys();</p>\n<p>console.log(mapIter.next().value); // \"0\"\nconsole.log(mapIter.next().value); // 1\nconsole.log(mapIter.next().value); // Object</p>\n<pre><code>8. Map.prototype.set: 设置一个key/value\n9. Map.prototype.values: 包含所有map的value值， 按插入顺序排序， 是一个迭代对象\n10. Map.prototype[@@iterator](): 设置自定义的iterator\n\n```js\nvar kvArray = [[\"key1\", \"value1\"], [\"key2\", \"value2\"]];\n\n// 使用常规的Map构造函数可以将一个二维键值对数组转换成一个Map对象\nvar myMap = new Map(kvArray);\n\nmyMap.get(\"key1\"); // 返回值为 \"value1\"\n\n// 使用Array.from函数可以将一个Map对象转换成一个二维键值对数组\nconsole.log(Array.from(myMap)); // 输出和kvArray相同的数组\n\n// 或者在键或者值的迭代器上使用Array.from，进而得到只含有键或者值的数组\nconsole.log(Array.from(myMap.keys())); // 输出 [\"key1\", \"key2\"]\n</code></pre>","frontmatter":{"title":"ES新语法点: entries | Map "}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/md/es6/es6/"}}}