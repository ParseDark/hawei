{"componentChunkName":"component---src-templates-blog-post-js","path":"/md/styled-component/base/","result":{"data":{"markdownRemark":{"html":"<h1>styled-components</h1>\n<p>是什么？ </p>\n<h1>Styled-Components是解决css-in-js较为成熟的npm包.</h1>\n<p>为什么， 解决了什么问题？ </p>\n<h1>主要解决的问题： css-in-js中的组织方式，把单纯的样式组件很好的使用可读性高的语法组织起来. 并且赋予简单并且强大的逻辑.</h1>\n<p>怎么做， 如何使用？ </p>\n<h2>使用</h2>\n<h3>1. 安装</h3>\n<pre><code class=\"language-shell\">npm install --save styled-components\n</code></pre>\n<h3>2. 基本语法</h3>\n<pre><code class=\"language-js\">// 导入\nimport styled from 'styled-components';\n\n// 使用styled关键字, 生成对应的样式组件\nconst Title = styled.h1`\n    font-size: 1.5em;\n`\n\nconst Wrapper = styled.section`\n    padding: 4rem;\n`\n\n() => {\n    // 在render函数中直接使用对应组件\n    return (\n        &#x3C;Wrapper>\n            &#x3C;Title>\n            &#x3C;/Title>\n        &#x3C;/Wrapper>\n    )\n}\n</code></pre>\n<h3>3. 适应Props</h3>\n<p>使用styled-components时， 我们可以对样式组件加入一些简单的样式. 在我们的模板字符串中， 我们可以获取默认的props.</p>\n<p>来看个例子</p>\n<pre><code class=\"language-js\">const Button = styled.button`\n  background: ${ props => props.primary ? 'palevioletred' : 'white'}\n  color: ${ props => props.primary ? 'white' :'palevioletred'}\n  font-size: 1em;\n  margin: 1em;\n  padding: 0.25em 1em;\n  border: 2px solid palevioletred;\n  border-radius: 3px;\n`\n\n() => {\n    return (\n        &#x3C;div>\n            &#x3C;Button>whte background-color and palevioletred color&#x3C;/Button> \n            &#x3C;Button primary>palevioletred background-color and white color&#x3C;/Button>\n        &#x3C;/div>\n    )\n}\n</code></pre>\n<h3>4. 扩展样式</h3>\n<p>对于原有的样式增加个性化的扩展.例如button的不同status.</p>\n<pre><code class=\"language-js\">const Button = style.button`\n  background: ${ props => props.primary ? 'palevioletred' : 'white'}\n  color: ${ props => props.primary ? 'white' :'palevioletred'}\n  font-size: 1em;\n  margin: 1em;\n  padding: 0.25em 1em;\n  border: 2px solid palevioletred;\n  border-radius: 3px;\n`\n\nconst TomatoButton = styled(Button)`\n    color: tomato;\n    border-color: tomato;\n`\n\n() => {\n\n    return (\n        &#x3C;div>\n            &#x3C;Button>&#x3C;/Button>\n            &#x3C;TomatoButton>&#x3C;/TomatoButton>\n        &#x3C;/div>\n    )\n}\n</code></pre>\n<h3>5. 元素转换</h3>\n<p>替换原有规则的标签.例如你的Button切换成a标签或许更合适.\nps: 注意，这条规则同时应用于用户自定义的元素.</p>\n<pre><code class=\"language-js\">const Button = styled.button`\n  display: inline-block;\n  color: palevioletred;\n  font-size: 1em;\n  margin: 1em;\n  padding: 0.25em 1em;\n  border: 2px solid palevioletred;\n  border-radius: 3px;\n  display: block;\n`;\nconst TomatoButton = styled(Button)`\n  color: tomato;\n  border-color: tomato;\n`;\nrender(\n  &#x3C;div>\n    &#x3C;Button>Normal Button&#x3C;/Button>\n    &#x3C;Button as=\"a\" href=\"/\">Link with Button styles&#x3C;/Button>\n    &#x3C;TomatoButton as=\"a\" href=\"/\">Link with Tomato Button styles&#x3C;/TomatoButton>\n  &#x3C;/div>\n);  \n</code></pre>\n<h3>6. 对任意的样式进行重写和扩展</h3>\n<p>对于任意的第三方UI库， 我们可以通过扩展语法自定义UI样式.</p>\n<pre><code class=\"language-js\">// This could be react-router-dom's Link for example\nconst Link = ({ className, children }) => (\n  &#x3C;a className={className}>\n    {children}\n  &#x3C;/a>\n);\nconst StyledLink = styled(Link)`\n  color: palevioletred;\n  font-weight: bold;\n`;\nrender(\n  &#x3C;div>\n    &#x3C;Link>Unstyled, boring Link&#x3C;/Link>\n    &#x3C;br />\n    &#x3C;StyledLink>Styled, exciting Link&#x3C;/StyledLink>\n  &#x3C;/div>\n);\n</code></pre>\n<h3>7. 属性传递</h3>\n<p>对于我们需要自定义的属性值， 我们可以通过props进行传递.// 例如color</p>\n<pre><code class=\"language-js\">// Create an Input component that'll render an &#x3C;input> tag with some styles\nconst Input = styled.input`\n  padding: 0.5em;\n  margin: 0.5em;\n  color: ${props => props.inputColor || \"palevioletred\"};\n  background: papayawhip;\n  border: none;\n  border-radius: 3px;\n`;\n// Render a styled text input with the standard input color, and one with a custom input color\nrender(\n  &#x3C;div>\n    &#x3C;Input defaultValue=\"@probablyup\" type=\"text\" />\n    &#x3C;Input defaultValue=\"@geelen\" type=\"text\" inputColor=\"rebeccapurple\" />\n  &#x3C;/div>\n);\n</code></pre>\n<h3>8. 推荐的样式管理</h3>\n<p>如果你常用css-in-modules， 那么你肯定习惯于使用scss或者less类似这样的库来进行样式分离, 然后把分离后的文件导入js/jsx.而在css-in-js中， 我们使用的是一种样式分离的风格来解决样式和代码分开.</p>\n<pre><code class=\"language-js\">import React from 'react'\nimport styled from 'styled-components'\n\nconst StyledCounter = styled.div`\n  /* ... */\n`\nconst Paragraph = styled.p`\n  /* ... */\n`\nconst Button = styled.button`\n  /* ... */\n`\n\nexport default class Counter extends React.Component {\n  state = { count: 0 }\n\n  increment = () => this.setState({ count: this.state.count + 1 })\n  decrement = () => this.setState({ count: this.state.count - 1 })\n\n  render() {\n    return (\n      &#x3C;StyledCounter>\n        &#x3C;Paragraph>{this.state.count}&#x3C;/Paragraph>\n        &#x3C;Button onClick={this.increment}>+&#x3C;/Button>\n        &#x3C;Button onClick={this.decrement}>-&#x3C;/Button>\n      &#x3C;/StyledCounter>\n    )\n  }\n}\n</code></pre>\n<h3>9. 把你的css-in-js代码写在组件体外.否则会有性能问题.</h3>\n<p>这个很好理解，如果是经常被调用的组件，每次都重新创建一次静态的样式组件， 那么就会产生性能损耗.</p>\n<pre><code class=\"language-js\">// 我们推荐的写法\nconst StyledWrapper = styled.div`\n  /* ... */\n`\n\nconst Wrapper = ({ message }) => {\n  return &#x3C;StyledWrapper>{message}&#x3C;/StyledWrapper>\n}\n</code></pre>\n<pre><code class=\"language-js\">// 反例: 把静态展示组件写在stateless组件中\nconst Wrapper = ({ message }) => {\n  // WARNING: THIS IS VERY VERY BAD AND SLOW, DO NOT DO THIS!!!\n  const StyledWrapper = styled.div`\n    /* ... */\n  `\n\n  return &#x3C;StyledWrapper>{message}&#x3C;/StyledWrapper>\n}\n</code></pre>\n<h3>10. 样式的嵌套/伪类/伪元素 规则</h3>\n<p>对于伪类和伪元素可以直接使用对应的语法</p>\n<pre><code class=\"language-js\">const Thing = styled.button`\n  color: blue;\n\n  ::before {\n    content: '🚀';\n  }\n\n  :hover {\n    color: red;\n  }\n`\n\nrender(\n  &#x3C;Thing>Hello world!&#x3C;/Thing>\n)\n</code></pre>\n<p>对于嵌套样式， 我们使用的是scss类似的嵌套语法.</p>\n<pre><code class=\"language-js\">const Thing = styled.div`\n  color: blue;\n\n  .something {\n    border: 1px solid; // an element labeled \".something\" inside &#x3C;Thing>\n    display: block;\n  }\n`\n\nrender(\n  &#x3C;Thing>\n    &#x3C;label htmlFor=\"foo-button\" className=\"something\">Mystery button&#x3C;/label>\n    &#x3C;button id=\"foo-button\">What do I do?&#x3C;/button>\n  &#x3C;/Thing>\n)\n</code></pre>\n<p>类似scss， 他也有&#x26;符号， 熟悉Scss的都知道&#x26;代表自己的意思.</p>\n<h3>11. 对元素的属性进行编辑___attrs</h3>\n<p>我们可以对标签上的原生属性进行操作， 比如input标签的type/placeholder属性等.</p>\n<pre><code class=\"language-js\">const Input = styled.input.attrs(props => ({\n  type: 'password',\n  size: props.size || '1em'\n}))`\n  color: palevioletred;\n  font-size: 1em;\n  border: 2px solid palevioletred;\n  border-radius: 3px;\n\n  /* here we use the dynamically computed prop */\n  margin: ${props => props.size};\n  padding: ${props => props.size};\n`\n\n() => {\n  &#x3C;div>\n    &#x3C;Input size='2em'>&#x3C;/Input>\n  &#x3C;/div>\n}\n</code></pre>\n<h3>12.animations____keyframes</h3>\n<p>在styled-components中，我们使用keyframes方法来模拟css3中的@keyframes.写法一致.</p>\n<pre><code class=\"language-js\">const rotate = keyframes`\n  from {\n    transform: rotate(0deg)\n  }\n\n  to {\n    transform: rotate(360deg)\n  }\n`\n\nconst Rotate = styled.div`\n  display : inline-block;\n  animation: ${rotate} 2s linear infinite;\n  padding: 2rem 1rem;\n  font-size: 1.2rem;\n  font-size: 1.2rem;\n`;\n\n() => {\n  return (\n    &#x3C;Rotate>&#x3C;/Rotate>\n  )\n}\n</code></pre>","frontmatter":{"title":"styled-components基础"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/md/styled-component/base/"}}}