{"componentChunkName":"component---src-templates-blog-post-js","path":"/md/计算机程序的构造和解释/chaper1: 构造过程抽象/","result":{"data":{"markdownRemark":{"html":"<h2>程序设计的基本元素</h2>\n<ol>\n<li>基本表达式： 例如语句定义， 运算符</li>\n<li>组合的方法: 函数定义， 分支， 循环语句</li>\n<li>抽象的方法： 例如prototype/class/compose结构</li>\n</ol>\n<p>在程序设计中，我们需要处理俩类原子： 过程和数据。（但是其实这俩者分得并没有那么仔细）</p>\n<p>数据是我们的操作对象， 而过程是对于我们操作对象的描述。</p>\n<p>所以， 对于任何强有力的语言都必须能够表述基本的数据和基本的过程， 还需要提供组合和抽象的方法。</p>\n<h3>表达式</h3>\n<p>你最开始输入的表达式是数。例如node的即时交互的terminal.</p>\n<pre><code class=\"language-bash\">>5\n5\n</code></pre>\n<p>下一步， 我们可以通过结合基本的表达式和运算符将表示的数组合起来， 形成复合表达式， 用以表达这些过程应用于这些数。</p>\n<pre><code class=\"language-bash\">> (+ 4 3)\n7\n</code></pre>\n<p>这就是组合式。</p>\n<p>在lisp中我们这种表达叫前缀表达式， 而在一些语言中， 是中缀表达式.例如js: 4 + 7</p>\n<p>当然， 前缀表达式有很多优点</p>\n<ol>\n<li>\n<p>适应任意数量的参数是优点之一。</p>\n<pre><code class=\"language-bash\">> (+ 3 5 5 3)\n</code></pre>\n<p>这里不会出现歧义， 对于该表达式的边界取决于右括号的位置。</p>\n</li>\n<li>\n<p>可直接扩充， 进行组合嵌套</p>\n<pre><code class=\"language-bash\">> (+ (* 3 5) (- 10 6))\n</code></pre>\n</li>\n</ol>\n<h3>命名和环境</h3>\n<p>程序设计的重要一点是， 它需要提供一种通过名字去使用计算对象的方式。我们将名字标识符称为变量， 它的值也就是它所对应的对象。</p>\n<p>在lisp中，我们使用的是define来完成。在完成定义后，我们就可以用定义的标识符来引用被标识的值。</p>\n<pre><code class=\"language-lisp\">(define size 2)\n\n(* 5 size)\n</code></pre>\n<p>define是我们使用语言中最简单的抽象方法， 允许我们使用一个简单， 有意义的名字去引用一个组合运算的结果。</p>\n<p>构造一个复杂的程序，也就是为了去一步步的创造出越来越复杂的计算性对象。用define进行逐步性的构造会变得非常方便。这也是鼓励大家使用递增的方式去开发与调试。</p>\n<blockquote>\n<p>lisp的程序总是由一大批相对简单的过程构成的.</p>\n</blockquote>\n<p>综上所述， 当我们把值与符号相关联， 之后通过符号来提取我们想要的值， 这意味着编译器必须维护某种存储能力， 以便于我们可以勇敢符号来访问到值， 这很像key-value对。这被成为环境， 编译器维护着一个环境(更精确的说， 是全局环境, 因为在接下来我们会看到一个计算过程中会涉及若干个不同环境).</p>\n<h3>组合式的求值</h3>\n<p>考虑一下， 对于一个组合式： (+ 1 (- 3 4))的求值过程是怎样的？</p>\n<ol>\n<li>求值该组合式的子表达式</li>\n<li>将最左边的操作符运用在step1完成的结果， 进行计算</li>\n</ol>\n<p>为了我们能实现组合式求值，我们必须先对组合式内的执行同样的步骤， 因此， 这一过程是递归的。</p>\n<p>递归， 简洁的描述了深度嵌套的情况.如果不使用递归， 我们就需要把组合式看成复杂的计算过程。</p>\n<pre><code class=\"language-lisp\">(* (+ 2 (* 4 6)\n   (+ 3 5 7)\n))\n</code></pre>\n<p>对于该复杂表达式，我们可以将其作为一颗树来描述， 每个组合作为一个带分支的节点。</p>\n<p>以树的观点看求职过程， 可以设想那些子树节点由下至上穿行， 在高层次中组合起来。我们应该把递归当作一种处理层次结构的有力技术。</p>\n<blockquote>\n<p>值向上穿行的求值形式是一类更一般的计算过程例子， 这种计算被称为树形积累。</p>\n</blockquote>\n<p>在我们反复的执行步骤1（对该组合式的子表达式求值）， 总可以把我们带到求值的某一点， 在这里遇到的不是组合， 而是基本表达式， 例如： 数，内部运算符， 或者其他名字。我们有如下规定</p>\n<ul>\n<li>数的值就是他们表示的值</li>\n<li>内部运算符的值就是能完成对应操作的机器码</li>\n<li>其他名字的值是在该环境下对应的这一名字的对象</li>\n</ul>\n<blockquote>\n<p>这里要指出，环境所扮演的对象正是用于确定表达式中各个符号的意义。</p>\n</blockquote>\n<blockquote>\n<p>对各种表达式的求职规则， 可以描述为一个简单的通用规则和一组针对不多形式的专门规则。</p>\n</blockquote>","frontmatter":{"title":"构造过程抽象"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/md/计算机程序的构造和解释/chaper1: 构造过程抽象/"}}}