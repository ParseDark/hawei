{"componentChunkName":"component---src-templates-blog-post-js","path":"/md/newBrowserApi/work/","result":{"data":{"markdownRemark":{"html":"<h1>webworker</h1>\n<p>我们知道js是单线程语言,虽然我们有类似于Promise/async/await/generator这样的语法，让我们进行一些异步操作.\n但是，对于一些大计算量的任务，js还无法胜任。\n于是我们有了webworker,webworker, 从主线程触发， 开辟独立于主线程之外的线程, 两者独立运行， 互不干扰。\n我们把一些阻塞UI渲染的操作放到worker中去进行计算，完成后返回给主线程， 主线程执行接下来的操作(一般都是异步的啊)。比较常见的应用有：文件上传， 接口调用， 独立渲染图层， 多线程渲染canvas不同区域.</p>\n<h2>定义</h2>\n<p>定义一个webworker非常简单， 使用浏览器自带的api即可.</p>\n<pre><code class=\"language-js\">// 1. 文件\nconst worker = new Worker('http://~.js')\n// 2. String\nconst data = `\n    //  worker线程 do something\n    `;\n// 转成二进制对象\nconst blob = new Blob([data]);\n// 生成url\nconst url = window.URL.createObjectURL(blob);\n// 加载url\nconst worker = new Worker(url);\n</code></pre>\n<p>worker存在的限制：</p>\n<blockquote>\n<p>分配给 Worker 线程运行的脚本文件，必须与主线程的脚本文件同源。</p>\n</blockquote>\n<blockquote>\n<p>worker 不能读取本地的文件(不能打开本机的文件系统file://)，它所加载的脚本必须来自网络。</p>\n</blockquote>\n<h2>worker与主进程通信</h2>\n<pre><code class=\"language-js\">// worker->主\n// 可以传递的信息包括： 对象和数组。（你肯定知道， 传递对象的时候要序列化数组， 所以你的对象不能包含function)\nworker.postMessage({\n    hello: ['hello', 'world']\n})\n</code></pre>\n<pre><code class=\"language-js\">// 主->worker:主线程监听worker线程回调函数\nworker.onmessage = function (e) {\n    console.log('父进程接收的数据：', e.data);\n    // doSomething();\n}\n</code></pre>\n<h2>关闭worker</h2>\n<p>这个肯定啊， 开启一个线程需要系统资源，不用了肯定关闭资源， 释放内存啊。</p>\n<pre><code class=\"language-js\">worker.terminate(); // 主线程关闭worker线程\n</code></pre>\n<h2>错误处理</h2>\n<p>对于异步操作我们都需要进行错误处理， promise我们使用catch， async/await我们使用try-catch语句.</p>\n<pre><code class=\"language-js\">// worker线程报错\nworker.onerror = e => {\n    // e.filename - 发生错误的脚本文件名；e.lineno - 出现错误的行号；以及 e.message - 可读性良好的错误消息\n    console.log('onerror', e);\n};\n</code></pre>\n<h2>worker内部</h2>\n<ol>\n<li>self/WorkerGlobalScope.\n像web对象， 我们有window， 指向当前上下文， 在webworker里， 我们使用self指向自己本身.</li>\n</ol>\n<pre><code class=\"language-js\">// 监听主线程传递过来的消息\nself.onmessage = e => {\n    console.log(\"主->work\")\n}\n// 发送消息给主线程\nself.postMessage({\n    hello: [ '这条信息', '来自worker线程' ]\n});\n//关闭自身\nself.close()\n\n// 线程加载外部脚本\n// 这里注意两点\n// 脚本中的全局变量都能被 worker 线程使用。\n// 脚本的下载顺序是不固定的，但执行时会按照传入 importScripts() 中的文件名顺序进行，这个过程是同步的。\nimportScripts('http~.js','http~2.js');\n</code></pre>\n<h2>webworker线程限制</h2>\n<p>因为 worker 创造了另外一个线程，不在主线程上，相应的会有一些限制，</p>\n<p>我们无法使用下列对象：</p>\n<ol>\n<li>window 对象</li>\n<li>document 对象</li>\n<li>DOM 对象</li>\n<li>parent 对象</li>\n</ol>\n<p>我们可以使用：</p>\n<ol>\n<li>浏览器：navigator 对象</li>\n<li>URL：location 对象，只读</li>\n<li>发送请求：XMLHttpRequest 对象</li>\n<li>定时器：setTimeout/setInterval，在 worker 线程轮询也是很棒！</li>\n<li>`应用缓存：Application Cache</li>\n</ol>","frontmatter":{"title":"webWorker 入坑","date":"29 March, 2020","tag":"worker","banner":"https://desk-fd.zol-img.com.cn/t_s960x600c5/g2/M00/04/0B/ChMlWl0-oHmIDZvqAAdz3RsOKEYAAMMNwPQhEkAB3P1417.jpg"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/md/newBrowserApi/work/"}}}