{"componentChunkName":"component---src-templates-blog-post-js","path":"/md/Structure and Interpretation of Computer Programs/chapter1: 构造过程抽象/","result":{"data":{"markdownRemark":{"html":"<h2>程序设计的基本元素</h2>\n<ol>\n<li>基本表达式： 例如语句定义， 运算符</li>\n<li>组合的方法: 函数定义， 分支， 循环语句</li>\n<li>抽象的方法： 例如prototype/class/compose结构</li>\n</ol>\n<p>在程序设计中，我们需要处理俩类原子： 过程和数据。（但是其实这俩者分得并没有那么仔细）</p>\n<p>数据是我们的操作对象， 而过程是对于我们操作对象的描述。</p>\n<p>所以， 对于任何强有力的语言都必须能够表述基本的数据和基本的过程， 还需要提供组合和抽象的方法。</p>\n<h3>表达式</h3>\n<p>你最开始输入的表达式是数。例如node的即时交互的terminal.</p>\n<pre><code class=\"language-bash\">>5\n5\n</code></pre>\n<p>下一步， 我们可以通过结合基本的表达式和运算符将表示的数组合起来， 形成复合表达式， 用以表达这些过程应用于这些数。</p>\n<pre><code class=\"language-bash\">> (+ 4 3)\n7\n</code></pre>\n<p>这就是组合式。</p>\n<p>在lisp中我们这种表达叫前缀表达式， 而在一些语言中， 是中缀表达式.例如js: 4 + 7</p>\n<p>当然， 前缀表达式有很多优点</p>\n<ol>\n<li>\n<p>适应任意数量的参数是优点之一。</p>\n<pre><code class=\"language-bash\">> (+ 3 5 5 3)\n</code></pre>\n<p>这里不会出现歧义， 对于该表达式的边界取决于右括号的位置。</p>\n</li>\n<li>\n<p>可直接扩充， 进行组合嵌套</p>\n<pre><code class=\"language-bash\">> (+ (* 3 5) (- 10 6))\n</code></pre>\n</li>\n</ol>\n<h3>命名和环境</h3>\n<p>程序设计的重要一点是， 它需要提供一种通过名字去使用计算对象的方式。我们将名字标识符称为变量， 它的值也就是它所对应的对象。</p>\n<p>在lisp中，我们使用的是define来完成。在完成定义后，我们就可以用定义的标识符来引用被标识的值。</p>\n<pre><code class=\"language-lisp\">(define size 2)\n\n(* 5 size)\n</code></pre>\n<p>define是我们使用语言中最简单的抽象方法， 允许我们使用一个简单， 有意义的名字去引用一个组合运算的结果。</p>\n<p>构造一个复杂的程序，也就是为了去一步步的创造出越来越复杂的计算性对象。用define进行逐步性的构造会变得非常方便。这也是鼓励大家使用递增的方式去开发与调试。</p>\n<blockquote>\n<p>lisp的程序总是由一大批相对简单的过程构成的.</p>\n</blockquote>\n<p>综上所述， 当我们把值与符号相关联， 之后通过符号来提取我们想要的值， 这意味着编译器必须维护某种存储能力， 以便于我们可以勇敢符号来访问到值， 这很像key-value对。这被成为环境， 编译器维护着一个环境(更精确的说， 是全局环境, 因为在接下来我们会看到一个计算过程中会涉及若干个不同环境).</p>\n<h3>组合式的求值</h3>\n<p>考虑一下， 对于一个组合式： (+ 1 (- 3 4))的求值过程是怎样的？</p>\n<ol>\n<li>求值该组合式的子表达式</li>\n<li>将最左边的操作符运用在step1完成的结果， 进行计算</li>\n</ol>\n<p>为了我们能实现组合式求值，我们必须先对组合式内的执行同样的步骤， 因此， 这一过程是递归的。</p>\n<p>递归， 简洁的描述了深度嵌套的情况.如果不使用递归， 我们就需要把组合式看成复杂的计算过程。</p>\n<pre><code class=\"language-lisp\">(* (+ 2 (* 4 6)\n   (+ 3 5 7)\n))\n</code></pre>\n<p>对于该复杂表达式，我们可以将其作为一颗树来描述， 每个组合作为一个带分支的节点。</p>\n<p>以树的观点看求职过程， 可以设想那些子树节点由下至上穿行， 在高层次中组合起来。我们应该把递归当作一种处理层次结构的有力技术。</p>\n<blockquote>\n<p>值向上穿行的求值形式是一类更一般的计算过程例子， 这种计算被称为树形积累。</p>\n</blockquote>\n<p>在我们反复的执行步骤1（对该组合式的子表达式求值）， 总可以把我们带到求值的某一点， 在这里遇到的不是组合， 而是基本表达式， 例如： 数，内部运算符， 或者其他名字。我们有如下规定</p>\n<ul>\n<li>数的值就是他们表示的值</li>\n<li>内部运算符的值就是能完成对应操作的机器码</li>\n<li>其他名字的值是在该环境下对应的这一名字的对象</li>\n</ul>\n<blockquote>\n<p>这里要指出，环境所扮演的对象正是用于确定表达式中各个符号的意义。</p>\n</blockquote>\n<blockquote>\n<p>对各种表达式的求值规则， 可以描述为一个简单的通用规则和一组针对不多形式的专门规则。</p>\n</blockquote>\n<h3>复合过程</h3>\n<p>我们已经了解了一些lisp的特性， 这在任何一种强有力的语言中都能看到。</p>\n<ul>\n<li>数和算数运算是基本的数据过程</li>\n<li>定义是一种受限的抽象手段， 它为名字关联对应的值</li>\n<li>组合式的嵌套提供了组织起多个操作的方法</li>\n</ul>\n<blockquote>\n<p>过程定义： 通过为复合操作提供名字， 而后将这些复合操作作为一个单元来使用。</p>\n</blockquote>\n<p>在lisp定义一个过程使用的还是define</p>\n<pre><code class=\"language-lisp\">(define (&#x3C;name> &#x3C;formal parameters>) &#x3C;body>)\n</code></pre>\n<ol>\n<li>name 作为这组操作集的符号</li>\n<li>formal parameters作为body内的形参, 会一一对应调用点的形参.</li>\n</ol>\n<p>当我们有了过程定义后， 我们可以通过组合， 形成更为复杂的过程定义。</p>\n<h3>过程应用的代换模型</h3>\n<p>对于组合式的求职， 跟之前计算（+ 3 5）的流程一致， 只不过算数运算符改成了我们的过程定义。\b</p>\n<p>简而言之， 就是我们把实参替换型参得到的结果， 放回原来的位置进行计算。完成代换。</p>\n<p>要注意： </p>\n<ol>\n<li>代换模型是为了让我们更好的去理解这个程序。而不是编译器的工作方式。</li>\n<li>代换模型是一种简单的， 不完备的模型， 在后面我们讨论变化的数据时， 该模型就不适用了。我们就需要更为复杂的模型。</li>\n</ol>\n<p><strong><em>应用序与正则序</em></strong></p>\n<p>正则序： 完全展开后归约计算。（在规约过程中可能回出现重复的计算）</p>\n<p>应用序： 先求值参数而后应用。（避免重复计算）</p>\n<pre><code class=\"language-lisp\">// 正则序\n(sum-of-squares (+ 5 1) (* 5 2))\n(+ (square (+ 5 1)) (square (* 5 2)))\n// 在这一步， 正则序执行了俩次 (* x x)\n(+ (* (+ 5 1) (+ 5 1)) (* (* 5 2) (* 5 2)))\n</code></pre>\n<h3>条件表达式和谓词</h3>\n<p>至此， 我们还没法解决一种场景， 检测某种情况， 根据结果去确定不同的操作。这种结构被称为分情况分析， 也叫分支结构。</p>\n<p>在LISP中对应关键字为<strong>cond</strong></p>\n<pre><code class=\"language-lisp\">(define (abs x)\n    (cond ((> x 0) x)\n          ((= x 0) 0)\n          ((&#x3C; x 0) -x)\n          (else 0)\n    )\n)\n\n(define (abs x)\n    (cond ((&#x3C; x 0) (- x))\n          (else x)\n    )\n)\n\n(define (abs x)\n    (if (&#x3C; x 0) (- x)\n        x\n    )\n)\n</code></pre>\n<p>与分支结构对应的还有逻辑运算符： AND || OR || NOT</p>\n<pre><code class=\"language-LISP\">(and c1 c2 c3)\n(or c1 c2 c3)\n(not c)\n</code></pre>\n<h3>过程作为黑箱抽象</h3>\n<p>一个过程的定义， 应该能隐藏一些细节。这样使使用这个过程的人， 不需要自己去写这些过程， 而是通过其他程序员那， 作为一个\n黑箱去接收它。一个用户在使用一个过程的时候， 应该不需要弄清这个程序是如何实现的。</p>\n<p><strong><em>局部名</em></strong></p>\n<hr>\n<p>在程序中， 用户不需要关注的细节之一， 就是形参的名称。这是实现这个程序的人决定的。</p>\n<p>程序的形参作为一种特殊的角色， 在这里， 形参的具体名字是什么， 完全没有任何关系。这样的名字叫做约束变量， 因此，一个程\n序的定义约束了它内部所有的形式参数。我们完全可以对形参做修改， 这也是重构的手法之一（函数改名， 变量改名）。</p>\n<p>如果一个变量， 不被约束， 我们就称他为自由变量， 自由变量的约束取决于定义他的作用域。</p>\n<p><strong><em>内部定义和块结构</em></strong></p>\n<hr>\n<p>简而言之， 通过在一个程序的结构体中去定义相关的子函数。这种嵌套被称为块结构。这里还有一个优点就是，我们可以通过最外层\n的函数定义，去共享变量。进而减少函数形参的数量。这种方式被称为词法作用于。在这个程序的内部就是共享变量的词法作用域。</p>\n<h2>过程与他们所产生的计算</h2>\n<p>在前面的章节， 我们了解到程序设计的一些要素： 基本算数操作， 对基本的算数操作进行组合， 通过定义复合过程对复合操作进行\n进一步的抽象。</p>\n<p>但是，我们就像棋手， 学会了规则， 却还不知道在编程领域中， 有各种常见的模式， 开局手段。</p>\n<blockquote>\n<p>能看清所考虑动作的后果的能力， 对于成为程序设计专家至为重要。</p>\n</blockquote>\n<p>在程序设计中，我们需要对计算过程中的各种行动作出规划， 用一个程序去控制这一过程的进展。要想成为专家， 我们就需要看清\n各种不同种类的程序会产生什么样的计算过程。只有在掌握了这种技能后， 我们才能学会如何去构造出可靠的程序， 使之能够表现\n预期的行为。</p>\n<p>一个过程也是一种模式， 它描述了一个计算过程的局部演化方式， 描述了这一计算过程中的每个步骤是怎样基于前一个步骤建立起来。</p>\n<h3>线性的递归和迭代</h3>\n<p>求一个正整数的阶乘。</p>\n<p>使用递归模型如下：</p>\n<pre><code class=\"language-lisp\">(define (factorial n)\n    (if (= n 1) \n        1\n        (* n (factorial (- n 1)))\n    )\n)\n</code></pre>\n<p>使用迭代模型： </p>\n<pre><code class=\"language-LISP\">(define (factorial n)\n    (fact-iter 1 1 n)\n)\n\n(define (fact-iter pro count max-count)\n    (if (> counter max-count)\n        pro\n        (fact-iter (* counter pro)\n                   (+ count 1)\n                    max-count\n        )\n    )\n)\n</code></pre>\n<p>在递归模型中， 他的代换模型后的结果是一个先展开， 后收缩的形状。在展开阶段， 这个计算过程构造出了一个推迟计算的过程，\n相应的， 编译器就需要去维护这个推迟的计算过程， 这杯成为递归计算过程。而在计算阶乘的时候， 推迟计算链长度为就是编译器\n需要去保存的链条长度。这个长度跟随N的增长， 线性增长。这个过程被成为线性递归过程。</p>\n<p>而与之相对应的迭代模型， 对于计算的任意一步来说， 需要的保存的只有三个迭代变量。pro/count/max-count.一般来说，\n迭代计算的过程就是其状态变量可以用固定数目的状态变量描述的计算过程。在计算阶乘的时候， 所需的计算步骤跟随N的增大而\n线性增长。这个过程被称为线性迭代。</p>\n<p>这里要注意的是， 对于递归来说，还存在着一些隐含的信息需要保存。相比于迭代来说， 我重启迭代的某个过程只需要保存对应\n的状态变量（上面的例子是： pro/count/max-count）, 而对于递归来说， 重启递归需要保存调用链， 这一链条越长， 则\n需要保存的信息就越多。</p>\n<h3>树形递归</h3>\n<p>斐波那契数列的计算就可以用树形递归表达。</p>\n<pre><code class=\"language-LISP\">(define (fib n)\n    (cond ((= n 0) 0)\n          ((= n 1) 1)\n          (else (+ (fib (- n 1)) (fib (- n 2))))\n    )\n)\n</code></pre>\n<p>计算fib 5就要计算出 fib 4 和 fib 3.每个调用中要调用俩次fib. </p>\n<p>但是在这个例子中， 我们做了很多的冗余计算， 例如： 在计算fib(5)的时候， 我们重复的去进行fib(3)的计算。 这是树形\n递归的典型案例，但却是很糟糕的斐波那契数列计算方法。</p>\n<p>但是树形递归并不是没有用，在处理层次结构的数据操作， 而不是对数进行操作时， 树形递归是一种自然的，威力强大的工具。\n即便是计算斐波那契数列， 树形递归的版本还是简洁的表达出我们的计算方法。但是要注意， 我们可以把递归转化为迭代。</p>\n<pre><code class=\"language-lisp\">(define (fib n)\n    (fib-iter 1 0 n)\n)\n\n(define (fib-iter a b count)\n    (if (= count 0) \n         b\n         (fib-iter (+ a b) a (- count 1))\n    )\n)\n</code></pre>\n<h3>阶的增长（参照大O表达法）</h3>\n<h2>用高阶函数抽象</h2>","frontmatter":{"title":"chapter1: 构造过程抽象"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/md/Structure and Interpretation of Computer Programs/chapter1: 构造过程抽象/"}}}